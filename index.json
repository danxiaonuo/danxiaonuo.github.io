[{"categories":["爱音乐爱生活"],"content":"我最喜欢的歌曲","date":"2020-10-11","objectID":"/%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E6%AD%8C%E6%9B%B2/","tags":["音乐"],"title":"我最喜欢的歌曲","uri":"/%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E6%AD%8C%E6%9B%B2/"},{"categories":["爱技术爱折腾"],"content":"k8s学习路径","date":"2020-11-05","objectID":"/k8s-summary/","tags":["k8s"],"title":"k8s学习路径","uri":"/k8s-summary/"},{"categories":["爱技术爱折腾"],"content":" 学习路径 ","date":"2020-11-05","objectID":"/k8s-summary/:0:0","tags":["k8s"],"title":"k8s学习路径","uri":"/k8s-summary/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes 介绍 0. 什么是Kubernetes 1. Kubernetes组件 ","date":"2020-11-05","objectID":"/k8s-summary/:1:0","tags":["k8s"],"title":"k8s学习路径","uri":"/k8s-summary/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes 入门 0. 学习Kubernetes基础知识 1. 部署一个应用程序 2. 查看 Pods / Nodes 3. 公布应用程序 4. 伸缩应用程序 5. 执行滚动更新 6. Kubernetes核心概念 ","date":"2020-11-05","objectID":"/k8s-summary/:2:0","tags":["k8s"],"title":"k8s学习路径","uri":"/k8s-summary/"},{"categories":["爱记录爱整理"],"content":"uola_docker使用介绍","date":"2021-03-20","objectID":"/uola_docker/","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"在win平台使用 ","date":"2021-03-20","objectID":"/uola_docker/:1:0","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"系统下载地址(包含uola镜像) 点击下载 ","date":"2021-03-20","objectID":"/uola_docker/:1:1","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"下载后解压压缩包文件,如下图 ","date":"2021-03-20","objectID":"/uola_docker/:1:2","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"需要安装vmware workstation后双击打开 ","date":"2021-03-20","objectID":"/uola_docker/:1:3","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"打开vm网络配置 ","date":"2021-03-20","objectID":"/uola_docker/:1:4","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"配置vm网络为桥接模式 ","date":"2021-03-20","objectID":"/uola_docker/:1:5","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"开启uola进入系统 用户：root 密码：admin ","date":"2021-03-20","objectID":"/uola_docker/:1:6","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"使用Xshell等终端软件登录系统,并获取网关与网段地址信息。 # 获取IPV4 网关地址命令 ip route | grep -i 'via' |awk 'END {print $3}' # 获取IPV6 网关地址命令 ip -6 route | grep -i 'via' |awk 'END {print $3}' # 获取IPV4 网段地址命令 ip a show bond0 | grep -v 'inet6' |grep -i inet | awk '{print $2}' ","date":"2021-03-20","objectID":"/uola_docker/:1:7","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"修改配置文件 修改第一处 # 进入配置文件目录 cd /data/uola_docker/ # 编辑docker-compose.yml文件 vi docker-compose.yml # 配置容器连接的网络 networks: macvLan: ipv4_address: 在此处写入IPV4地址,必须与网关地址在同一网段,并且此IPV4地址未被使用,例如10.8.1.253。 ================================================================================ networks: macvLan: driver: macvlan enable_ipv6: true driver_opts: parent: bond0 macvlan_mode: bridge ipam: config: - subnet: 2001::0/64 gateway: 2001::1 - subnet: IPV4网段(用第六步的方法获取网段地址) gateway: IPV4网关地址(使用第六步的方法获取网关地址) ================================================================================ 修改第二处 # 进入配置文件目录 cd /data/uola_docker/uola/system/etc/config # 编辑network文件 vi network config interface 'lan' option ifname 'eth0' option proto 'static' option netmask '255.255.255.0' option ip6assign '64' option ip6hint '0' option ipaddr '在此处写入IPV4地址(必须与ipv4_address地址相同),例如10.8.1.253' option gateway 'IPV4网关地址' option dns 'IPV4网关地址' option ip6ifaceid '在此处写入IPV6地址后缀,例如::253' ","date":"2021-03-20","objectID":"/uola_docker/:1:8","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"启动容器 # 进入配置文件目录 cd /data/uola_docker/ # 启动容器 docker-compose up -d ","date":"2021-03-20","objectID":"/uola_docker/:1:9","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"打开浏览器,进入web端,填入IP地址(第七步的ipv4_address地址),并修改密码。 登录web账号与密码 用户：root 密码：admin 系统——》管理权——》主机密码 ","date":"2021-03-20","objectID":"/uola_docker/:1:10","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"在win平台配置 设置 -\u003e 网络和Internet -\u003e 更改适配器选项 修改默认网关与首先DSN服务器地址填入第七步的ipv4_address地址。 ","date":"2021-03-20","objectID":"/uola_docker/:1:11","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"在linux平台使用 ","date":"2021-03-20","objectID":"/uola_docker/:2:0","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"克隆Github仓库代码 git clone --depth 1 https://github.com/danxiaonuo/uola_docker ","date":"2021-03-20","objectID":"/uola_docker/:2:1","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"使用Xshell等终端软件登录系统,并获取网关与网段地址信息。 # 获取IPV4 网关地址命令 ip route | grep -i 'via' |awk 'END {print $3}' # 获取IPV6 网关地址命令 ip -6 route | grep -i 'via' |awk 'END {print $3}' # 获取IPV4 网段地址命令 ip a show bond0 | grep -v 'inet6' |grep -i inet | awk '{print $2}' ","date":"2021-03-20","objectID":"/uola_docker/:2:2","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"修改配置文件 修改第一处 # 进入配置文件目录 cd uola_docker # 编辑docker-compose.yml文件 vi docker-compose.yml # 配置容器连接的网络 networks: macvLan: ipv4_address: 在此处写入IPV4地址,必须与网关地址在同一网段,并且此IPV4地址未被使用,例如10.8.1.253。 ================================================================================ networks: macvLan: driver: macvlan enable_ipv6: true driver_opts: parent: bond0 macvlan_mode: bridge ipam: config: - subnet: 2001::0/64 gateway: 2001::1 - subnet: IPV4网段(用第六步的方法获取网段地址) gateway: IPV4网关地址(使用第六步的方法获取网关地址) ================================================================================ 修改第二处 # 进入配置文件目录 cd uola_docker/uola/system/etc/config # 编辑network文件 vi network config interface 'lan' option ifname 'eth0' option proto 'static' option netmask '255.255.255.0' option ip6assign '64' option ip6hint '0' option ipaddr '在此处写入IPV4地址(必须与ipv4_address地址相同),例如10.8.1.253' option gateway 'IPV4网关地址' option dns 'IPV4网关地址' option ip6ifaceid '在此处写入IPV6地址后缀,例如::253' ","date":"2021-03-20","objectID":"/uola_docker/:2:3","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"启动容器 # 进入配置文件目录 cd uola_docker # 启动容器 docker-compose up -d ","date":"2021-03-20","objectID":"/uola_docker/:2:4","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"打开浏览器,进入web端,填入IP地址(第七步的ipv4_address地址),并修改密码。 登录web账号与密码 用户：root 密码：admin 系统——》管理权——》主机密码 ","date":"2021-03-20","objectID":"/uola_docker/:2:5","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱记录爱整理"],"content":"路由器修改网关地址与DNS地址(统一修改为uola的ipv4地址) 以tp-link路由器为例,如下截图。 ","date":"2021-03-20","objectID":"/uola_docker/:3:0","tags":["uola","docker"],"title":"uola_docker","uri":"/uola_docker/"},{"categories":["爱技术爱折腾"],"content":"介绍Kubernetes是什么","date":"2020-11-05","objectID":"/what-is-k8s/","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes介绍","uri":"/what-is-k8s/"},{"categories":["爱技术爱折腾"],"content":" 参考文档： Kubernetes 是什么，并有所改写。 Kubernetes是一个可以移植、可扩展的开源平台，使用 声明式的配置 并依据配置信息自动地执行容器化应用程序的管理。在所有的容器编排工具中（类似的还有 docker swarm / mesos等），Kubernetes的生态系统更大、增长更快，有更多的支持、服务和工具可供用户选择。 Kubernetes的名字起源于希腊语，含义是 舵手、领航员、向导。Google于2014年将Brog系统开源为Kubernetes。Kubernetes构建在Google Brog 十五年运行大规模分布式系统的经验 基础之上，并结合了开源社区最好的想法和实践。 以下是使用 google trends 对比 kubernetes 、 docker swarm、 mesos 三个关键词的截图。 ","date":"2020-11-05","objectID":"/what-is-k8s/:0:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes介绍","uri":"/what-is-k8s/"},{"categories":["爱技术爱折腾"],"content":"回顾 为了理解Kubernetes的用处，我们先回顾一下历史。 大致来说，在部署应用程序的方式上，我们主要经历了三个时代： 传统部署时代：早期，企业直接将应用程序部署在物理机上。由于物理机上不能为应用程序定义资源使用边界，我们也就很难合理地分配计算资源。例如：如果多个应用程序运行在同一台物理机上，可能发生这样的情况：其中的一个应用程序消耗了大多数的计算资源，导致其他应用程序不能正常运行。应对此问题的一种解决办法是，将每一个应用程序运行在不同的物理机上。然而，这种做法无法大规模实施，因为资源利用率很低，且企业维护更多物理机的成本昂贵。 虚拟化部署时代：针对上述问题，虚拟化技术应运而生。用户可以在单台物理机的CPU上运行多个虚拟机（Virtual Machine）。 虚拟化技术使得应用程序被虚拟机相互分隔开，限制了应用程序之间的非法访问，进而提供了一定程度的安全性。 虚拟化技术提高了物理机的资源利用率，可以更容易地安装或更新应用程序，降低了硬件成本，因此可以更好地规模化实施。 每一个虚拟机可以认为是被虚拟化的物理机之上的一台完整的机器，其中运行了一台机器的所有组件，包括虚拟机自身的操作系统。 容器化部署时代：容器与虚拟机类似，但是降低了隔离层级，共享了操作系统。因此，容器可以认为是轻量级的。 与虚拟机相似，每个容器拥有自己的文件系统、CPU、内存、进程空间等 运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦 容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署 容器化越来越流行，主要原因是它带来的诸多好处： 敏捷地创建和部署应用程序：相较于创建虚拟机镜像，创建容器镜像更加容易和快速 持续构建集成：可以更快更频繁地构建容器镜像、部署容器化的应用程序、并且轻松地回滚应用程序 分离开发和运维的关注点：在开发构建阶段就完成容器镜像的构建，构建好的镜像可以部署到多种基础设施上。这种做法将开发阶段需要关注的内容包含在如何构建容器镜像的过程中，将部署阶段需要关注的内容聚焦在如何提供基础设施以及如何使用容器镜像的过程中。降低了开发和运维的耦合度 可监控性：不仅可以查看操作系统级别的资源监控信息，还可以查看应用程序健康状态以及其他信号的监控信息 开发、测试、生产不同阶段的环境一致性：开发阶段在笔记本上运行的容器与测试、生产环境中运行的容器一致 跨云服务商、跨操作系统发行版的可移植性：容器可运行在 Ubuntu、RHEL、CoreOS、CentOS等不同的操作系统发行版上，可以运行在私有化部署、Google Kubernetes Engine、AWS、阿里云等不同的云供应商的环境中 以应用程序为中心的管理：虚拟机时代的考虑的问题是在虚拟硬件上运行一个操作系统，而容器化时代，问题的焦点则是在操作系统的逻辑资源上运行一个应用程序 松耦合、分布式、弹性、无约束的微服务：应用程序被切分成更小的、独立的微服务，并可以动态部署和管理，而不是一个部署在专属机器上的庞大的单片应用程序 资源隔离：确保应用程序性能不受干扰 资源利用：资源高效、高密度利用 ","date":"2020-11-05","objectID":"/what-is-k8s/:1:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes介绍","uri":"/what-is-k8s/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes的功能 容器是一个非常好的打包并运行应用程序的方式。在生产环境中，您需要管理容器化应用程序，并且确保其不停机地连续运行。例如：一个容器故障停机，另外一个容器需要立刻启动以替补停机的容器。类似的这种对容器的管理动作由系统来执行会更好更快速。 Kubernetes针对此类问题，提供了容器化编排解决方案，可以使你非常健壮地运行分布式系统。Kubernetes可以处理应用程序的伸缩、failover、部署模式等多种需求。例如，Kubernetes可以轻易地管理系统的金丝雀发布（灰度发布）。 Kubernetes提供的特性有： 服务发现和负载均衡 Kubernetes 可以通过 DNS 名称或 IP 地址暴露容器的访问方式。并且可以在同组容器内分发负载以实现负载均衡 存储编排 Kubernetes可以自动挂载指定的存储系统，例如 local stroage/nfs/云存储等 自动发布和回滚 您可以在 Kubernetes 中声明您期望应用程序容器应该达到的状态，Kubernetes将以合适的速率调整容器的实际状态，并逐步达到最终期望的结果。请参考 声明式的配置 自愈 Kubernetes提供如下自愈能力： 重启已经停机的容器 替换、kill 那些不满足自定义健康检查条件的容器 在容器就绪之前，避免调用者发现该容器 密钥及配置管理 Kubernetes可以存储和管理敏感信息（例如，密码、OAuth token、ssh密钥等）。您可以更新容器应用程序的密钥、配置等信息，而无需： 重新构建容器的镜像 在不合适的地方暴露密码信息 ","date":"2020-11-05","objectID":"/what-is-k8s/:2:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes介绍","uri":"/what-is-k8s/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes的边界 Kubernetes不是一个传统意义的、保罗万象的 PaaS（Platform as a Service）系统。Kubernetes在容器层面工作，而不是硬件层面，它提供了与 PaaS 平台相似的通用特性，例如：部署、伸缩、负载均衡、日志、监控等。然而，Kubernetes并不是一个单一整体，这些特性都是可选、可插拔的。Kubernetes提供用于搭建开发平台的基础模块，同时为用户提供了不同模块的选择性和多样性。 Kubernetes： 不限制应用程序的类型。Kubernetes的目标是广泛支持不同类型的工作负载，包括：有状态、无状态、数据处理等类型的应用。只要应用可以在容器中运行，就能够非常好地在 Kubernetes 上运行 不部署源码、不编译或构建应用程序。持续集成、分发、部署（CI/CD）的工作流极大程度上取决于组织的文化、偏好以及技术要求。Kubernetes可以作为部署平台参与到 CI/CD 流程，但是不涉及镜像构建和分发的过程 译者注：可选的有 Jenkins / Gitlab Runner / docker registry / harbour 等 不提供应用程序级别的服务，包括：中间件（例如，消息总线）、数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存（例如，Redis），或者分布式存储（例如，Ceph）。此类组件可以在 Kubernetes 上运行，或者可以被运行在 Kubernetes 上的应用程序访问 不限定日志、监控、报警的解决方案。Kubernetes 提供一些样例展示如何与日志、监控、报警等组件集成，同时提供收集、导出监控度量（metrics）的一套机制。您可以根据自己的需要选择日志、监控、报警组件 译者注：可选的有 ELK / Prometheus / Graphana / Pinpoint / Skywalking / Metrics Server 等 不提供或者限定配置语言（例如，jsonnet）。Kubernetes提供一组声明式的 API，您可以按照自己的方式定义部署信息。 译者注：可选的有 helm/kustomize/kubectl/kubernetes dashboard/kuboard/octant/k9s 等 不提供或限定任何机器的配置、维护、管理或自愈的系统。 译者注：在这个级别上，可选的组件有 puppet、ansible、open stack 等 此外，Kubernetes不是一个纯粹意义上的容器编排系统。事实上，Kubernetes 消除了容器编排的需求。容器编排的技术定义是预定义流程的执行（先做A、再做B、然后做C）。与此相对应，Kubernetes构建了一系列相互独立、可预排的控制过程，以持续不断地将系统从当前状态调整到声明的目标状态。如何从 A 达到 C，并不重要。集中化的控制也就不需要了。这个设计思想使得Kubernetes使用更简单、更强大、稳健、反脆弱和可扩展。 ","date":"2020-11-05","objectID":"/what-is-k8s/:3:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes介绍","uri":"/what-is-k8s/"},{"categories":["爱技术爱折腾"],"content":"描述了 Kubernetes 的主要组件","date":"2020-11-05","objectID":"/component/","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":" 参考文档： Kubernetes 组件，并有所改写。 本文档描述了 Kubernetes 的主要组件。 ","date":"2020-11-05","objectID":"/component/:0:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"Master组件 Master组件是集群的控制平台（control plane）： master 组件负责集群中的全局决策（例如，调度） master 组件探测并响应集群事件（例如，当 Deployment 的实际 Pod 副本数未达到 replicas 字段的规定时，启动一个新的 Pod） Master组件可以运行于集群中的任何机器上。但是，为了简洁性，通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器。 ","date":"2020-11-05","objectID":"/component/:1:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"kube-apiserver 此 master 组件提供 Kubernetes API。这是Kubernetes控制平台的前端（front-end），可以水平扩展（通过部署更多的实例以达到性能要求）。kubectl / kubernetes dashboard / kuboard 等Kubernetes管理工具就是通过 kubernetes API 实现对 Kubernetes 集群的管理。 ","date":"2020-11-05","objectID":"/component/:1:1","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"etcd 支持一致性和高可用的名值对存储组件，Kubernetes集群的所有配置信息都存储在 etcd 中。请确保您 备份 了 etcd 的数据。关于 etcd 的更多信息，可参考 etcd 官方文档 ","date":"2020-11-05","objectID":"/component/:1:2","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"kube-scheduler 此 master 组件监控所有新创建尚未分配到节点上的 Pod，并且自动选择为 Pod 选择一个合适的节点去运行。 影响调度的因素有： 单个或多个 Pod 的资源需求 硬件、软件、策略的限制 亲和与反亲和（affinity and anti-affinity）的约定 数据本地化要求 工作负载间的相互作用 ","date":"2020-11-05","objectID":"/component/:1:3","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"kube-controller-manager 此 master 组件运行了所有的控制器 逻辑上来说，每一个控制器是一个独立的进程，但是为了降低复杂度，这些控制器都被合并运行在一个进程里。 kube-controller-manager 中包含的控制器有： 节点控制器： 负责监听节点停机的事件并作出对应响应 副本控制器： 负责为集群中每一个 副本控制器对象（Replication Controller Object）维护期望的 Pod 副本数 端点（Endpoints）控制器：负责为端点对象（Endpoints Object，连接 Service 和 Pod）赋值 Service Account \u0026 Token控制器： 负责为新的名称空间创建 default Service Account 以及 API Access Token ","date":"2020-11-05","objectID":"/component/:1:4","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"cloud-controller-manager cloud-controller-manager 中运行了与具体云基础设施供应商互动的控制器 cloud-controller-manager 只运行特定于云基础设施供应商的控制器 cloud-controller-manager 使得云供应商的代码和 Kubernetes 的代码可以各自独立的演化。在此之前的版本中，Kubernetes的核心代码是依赖于云供应商的代码的。在后续的版本中，特定于云供应商的代码将由云供应商自行维护，并在运行Kubernetes时链接到 cloud-controller-manager。 以下控制器中包含与云供应商相关的依赖： 节点控制器：当某一个节点停止响应时，调用云供应商的接口，以检查该节点的虚拟机是否已经被云供应商删除。 译者注：私有化部署Kubernetes时，我们不知道节点的操作系统是否删除，所以在移除节点后，要自行通过 kubectl delete node 将节点对象从 Kubernetes 中删除。 路由控制器：在云供应商的基础设施中设定网络路由 译者注：私有化部署Kubernetes时，需要自行规划Kubernetes的拓扑结构，并做好路由配置，例如 安装Kubernetes单Master节点 中所作的。 服务（Service）控制器：创建、更新、删除云供应商提供的负载均衡器 译者注：私有化部署Kubernetes时，不支持 LoadBalancer 类型的 Service，如需要此特性，需要创建 NodePort 类型的 Service，并自行配置负载均衡器。 数据卷（Volume）控制器：创建、绑定、挂载数据卷，并协调云供应商编排数据卷 译者注：私有化部署Kubernetes时，需要自行创建和管理存储资源，并通过Kubernetes的存储类、存储卷、数据卷等与之关联。 译者注：通过 cloud-controller-manager，Kubernetes可以更好地与云供应商结合，例如，在阿里云的 Kubernetes 服务里，您可以在云控制台界面上轻松点击鼠标，即可完成 Kubernetes 集群的创建和管理。在私有化部署环境时，您必须自行处理更多的内容。幸运的是，通过合适的教程指引，这些任务的达成并不困难。 ","date":"2020-11-05","objectID":"/component/:1:5","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"Node 组件 Node 组件运行在每一个节点上（包括 master 节点和 worker 节点），负责维护运行中的 Pod 并提供 Kubernetes 运行时环境。 ","date":"2020-11-05","objectID":"/component/:2:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"kubelet 此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。 ","date":"2020-11-05","objectID":"/component/:2:1","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"kube-proxy kube-proxy 是一个网络代理程序，运行在集群中的每一个节点上，是实现 Kubernetes Service 概念的重要部分。 kube-proxy 在节点上维护网络规则。这些网络规则使得您可以在集群内、集群外正确地与 Pod 进行网络通信。如果操作系统中存在 packet filtering layer，kube-proxy 将使用这一特性（iptables代理模式），否则，kube-proxy将自行转发网络请求（User space代理模式）。 ","date":"2020-11-05","objectID":"/component/:2:2","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"容器引擎 容器引擎负责运行容器。Kubernetes支持多种容器引擎：Docker、containerd、cri-o、rktlet 以及任何实现了 Kubernetes容器引擎接口 的容器引擎。 ","date":"2020-11-05","objectID":"/component/:2:3","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"安装扩展（Addons） Addons 使用 Kubernetes 资源（DaemonSet、Deployment等）实现集群的功能特性。由于他们提供集群级别的功能特性，addons使用到的Kubernetes资源都放置在 kube-system 名称空间下。 下面描述了一些经常用到的 addons，参考 安装扩展（Addons） 查看更多列表。 ","date":"2020-11-05","objectID":"/component/:3:0","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"DNS 除了 DNS Addon 以外，其他的 addon 都不是必须的，所有 Kubernetes 集群都应该有 Cluster DNS Cluster DNS 是一个 DNS 服务器，是对您已有环境中其他 DNS 服务器的一个补充，存放了 Kubernetes Service 的 DNS 记录。 Kubernetes 启动容器时，自动将该 DNS 服务器加入到容器的 DNS 搜索列表中。 ","date":"2020-11-05","objectID":"/component/:3:1","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"Web 界面 (Dashboard) Web 界面 (Dashboard) 是一个Kubernetes集群的 Web 管理界面。用户可以通过该界面管理集群。 ","date":"2020-11-05","objectID":"/component/:3:2","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"资源监控工具 资源监控工具 将容器的度量指标（metrics）记录在时间序列数据库中，并提供了 UI 界面查看这些数据。 ","date":"2020-11-05","objectID":"/component/:3:3","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"日志架构 日志架构 机制负责将容器的日志存储到一个统一存储中，并提供搜索浏览的界面。 ","date":"2020-11-05","objectID":"/component/:3:4","tags":["k8s","Kubernetes 介绍"],"title":"Kubernetes组件","uri":"/component/"},{"categories":["爱技术爱折腾"],"content":"使用kubectl创建一个Deployment","date":"2020-11-05","objectID":"/deploy-app/","tags":["k8s","Kubernetes 入门"],"title":"部署一个应用程序","uri":"/deploy-app/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes 部署 Deployment 译名为 部署。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 Pod 的概念中，Pod 是 k8s 中最小可管理单元。 在 k8s 集群中发布 Deployment 后，Deployment 将指示 k8s 如何创建和更新应用程序的实例，master 节点将应用程序实例调度到集群中的具体的节点上。 创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。这提供了一种自我修复机制来解决机器故障或维护问题。 在容器编排之前的时代，各种安装脚本通常用于启动应用程序，但是不能够使应用程序从机器故障中恢复。通过创建应用程序实例并确保它们在集群节点中的运行实例个数，Kubernetes Deployment 提供了一种完全不同的方式来管理应用程序。 ","date":"2020-11-05","objectID":"/deploy-app/:1:0","tags":["k8s","Kubernetes 入门"],"title":"部署一个应用程序","uri":"/deploy-app/"},{"categories":["爱技术爱折腾"],"content":"在 Kubernetes 上部署第一个应用程序 上图是在第一篇文章的基础上，添加上了Deployment、Pod和Container。 Deployment 处于 master 节点上，通过发布 Deployment，master 节点会选择合适的 worker 节点创建 Container（即图中的正方体），Container 会被包含在 Pod （即蓝色圆圈）里。 ","date":"2020-11-05","objectID":"/deploy-app/:2:0","tags":["k8s","Kubernetes 入门"],"title":"部署一个应用程序","uri":"/deploy-app/"},{"categories":["爱技术爱折腾"],"content":"实战：部署 nginx Deployment 使用 kubectl创建 apiVersion: apps/v1 #与k8s集群版本有关，使用 kubectl api-versions or kubectl explain deployment即可查看当前集群支持的版本 kind: Deployment #该配置的类型，我们使用的是 Deployment metadata: #译名为元数据，即 Deployment 的一些基本属性和信息 name: nginx-deployment #Deployment 的名称 labels: #标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解 app: nginx #为该Deployment设置key为app，value为nginx的标签 spec: #这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用 replicas: 1 #使用该Deployment创建一个应用程序实例 selector: #标签选择器，与上面的标签共同作用，目前不需要理解 matchLabels: #选择包含标签app:nginx的资源 app: nginx template: #这是选择或创建的Pod的模板 metadata: #Pod的元数据 labels: #Pod的标签，上面的selector即选择包含标签app:nginx的Pod app: nginx spec: #期望Pod实现的功能（即在pod中部署） containers: #生成container，与docker中的container是同一种 - name: nginx #container的名称 image: nginx:1.19.3 #使用镜像nginx:1.19.3创建container，该container默认80端口可访问 apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.19.3 应用 YAML 文件 kubectl apply -f nginx-deployment.yaml 查看部署结果 # 查看 Deployment kubectl get deployments # 查看 Pod kubectl get pods 可分别查看到一个名为 nginx-deployment 的 Deployment 和一个名为 nginx-deployment-xxxxxxx 的 Pod ","date":"2020-11-05","objectID":"/deploy-app/:3:0","tags":["k8s","Kubernetes 入门"],"title":"部署一个应用程序","uri":"/deploy-app/"},{"categories":["爱技术爱折腾"],"content":"介绍了如何使用kubectl查看和浏览Kubernetes上的节点_容器组_部署等信息_并依据这些信息作出问题诊断","date":"2020-11-05","objectID":"/explore-intro/","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":" 参考文档：查看 pod 和工作节点 ，并有所改写。 ","date":"2020-11-05","objectID":"/explore-intro/:0:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"目标 了解Kubernetes Pods（容器组） 了解Kubernetes Nodes（节点） 排查故障 ","date":"2020-11-05","objectID":"/explore-intro/:1:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes Pods 在 部署第一个应用程序 中创建 Deployment 后，k8s创建了一个 Pod（容器组） 来放置应用程序实例（container 容器）。 ","date":"2020-11-05","objectID":"/explore-intro/:2:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"Pods概述 Pod 容器组 是一个k8s中一个抽象的概念，用于存放一组 container（可包含一个或多个 container 容器，即图上正方体)，以及这些 container （容器）的一些共享资源。这些资源包括： 共享存储，称为卷(Volumes)，即图上紫色圆柱 网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址 container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等 例如，Pod可能既包含带有Node.js应用程序的 container 容器，也包含另一个非 Node.js 的 container 容器，用于提供 Node.js webserver 要发布的数据。Pod中的容器共享 IP 地址和端口空间（同一 Pod 中的不同 container 端口不能相互冲突），始终位于同一位置并共同调度，并在同一节点上的共享上下文中运行。（同一个Pod内的容器可以使用 localhost + 端口号互相访问）。 Pod（容器组）是 k8s 集群上的最基本的单元。当我们在 k8s 上创建 Deployment 时，会在集群上创建包含容器的 Pod (而不是直接创建容器)。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同）。 tip 重要： Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。 如果多个容器紧密耦合并且需要共享磁盘等资源，则他们应该被部署在同一个Pod（容器组）中。 ","date":"2020-11-05","objectID":"/explore-intro/:3:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"Node（节点） 下图显示一个 Node（节点）上含有4个 Pod（容器组） Pod（容器组）总是在 Node（节点） 上运行。Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。每个 Node（节点）都由 master 管理。一个 Node（节点）可以有多个Pod（容器组），kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。 每个 Kubernetes Node（节点）至少运行： Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。 容器运行环境（如Docker）负责下载镜像、创建和运行容器等。 ","date":"2020-11-05","objectID":"/explore-intro/:4:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"实战：故障排除 在部署第一个应用程序 中，我们使用了 kubectl 命令行界面部署了 nginx 并且查看了 Deployment 和 Pod。kubectl 还有如下四个常用命令，在我们排查问题时可以提供帮助： kubectl get - 显示资源列表 # kubectl get 资源类型 #获取类型为Deployment的资源列表 kubectl get deployments #获取类型为Pod的资源列表 kubectl get pods #获取类型为Node的资源列表 kubectl get nodes tip 在命令后增加 -A 或 --all-namespaces 可查看所有 名称空间中 的对象，使用参数 -n 可查看指定名称空间的对象，例如 # 查看所有名称空间的 Deployment kubectl get deployments -A kubectl get deployments --all-namespaces # 查看 kube-system 名称空间的 Deployment kubectl get deployments -n kube-system 并非所有对象都在名称空间里 kubectl describe - 显示有关资源的详细信息 # kubectl describe 资源类型 资源名称 #查看名称为nginx-XXXXXX的Pod的信息 kubectl describe pod nginx-XXXXXX #查看名称为nginx的Deployment的信息 kubectl describe deployment nginx kubectl logs - 查看pod中的容器的打印日志（和命令docker logs 类似） # kubectl logs Pod名称 #查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志 #本案例中的 nginx-pod 没有输出日志，所以您看到的结果是空的 kubectl logs -f nginx-pod-XXXXXXX kubectl exec - 在pod中的容器环境内执行命令(和命令docker exec 类似) # kubectl exec Pod名称 操作命令 # 在名称为nginx-pod-xxxxxx的Pod中运行bash kubectl exec -it nginx-pod-xxxxxx -- /bin/bash 请尝试在您的集群中执行一下上述的几个命令，了解如何通过 kubectl 操作 kubernetes 集群中的 Node、Pod、Container。 tip Worker节点是k8s中的工作计算机，可能是VM或物理计算机，具体取决于群集。多个Pod可以在一个节点上运行。 ","date":"2020-11-05","objectID":"/explore-intro/:5:0","tags":["k8s","Kubernetes 入门"],"title":"查看Pods/Nodes","uri":"/explore-intro/"},{"categories":["爱技术爱折腾"],"content":"学习Kubernetes基础知识","date":"2020-11-05","objectID":"/kubernetes-basics/","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱技术爱折腾"],"content":" 参考文档：学习Kubernetes基础知识 ，并有所改写。 ","date":"2020-11-05","objectID":"/kubernetes-basics/:0:0","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱技术爱折腾"],"content":"学习目标 在k8s集群上部署应用程序 对应用程序进行扩容缩容（多实例） 对应用程序进行版本更新 使用k8s工具排查部署问题 ","date":"2020-11-05","objectID":"/kubernetes-basics/:1:0","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes功能 官方定义k8s能够对容器化软件进行部署管理，在不停机的前提下提供简单快速的发布和更新方式。换句话说，如果项目需要多机器节点的微服务架构，并且采用Docker image（镜像）进行容器化部署，那么k8s可以帮助我们屏蔽掉集群的复杂性，自动选择最优资源分配方式进行部署。在此基础上，k8s还提供简单的多实例部署及更新方案，仅需几个操作命令就可以轻松实现。 ","date":"2020-11-05","objectID":"/kubernetes-basics/:2:0","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱技术爱折腾"],"content":"Kubernetes 入门目录 01.部署第一个应用程序 02.查看 Pods / Nodes 03.公布应用程序 04.伸缩应用程序 05.执行滚动更新 ","date":"2020-11-05","objectID":"/kubernetes-basics/:3:0","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱技术爱折腾"],"content":"k8s集群简单介绍 上图描述的是拥有一个Master(主)节点和六个Worker(工作)节点的k8s集群 Master 负责管理集群 负责协调集群中的所有活动，例如调度应用程序，维护应用程序的状态，扩展和更新应用程序。 Worker节点(即图中的Node)是VM(虚拟机)或物理计算机，充当k8s集群中的工作计算机。 每个Worker节点都有一个Kubelet，它管理该Worker节点并负责与Master节点通信。该Worker节点还应具有用于处理容器操作的工具，例如Docker。 ","date":"2020-11-05","objectID":"/kubernetes-basics/:4:0","tags":["k8s","Kubernetes 入门"],"title":"学习Kubernetes基础知识","uri":"/kubernetes-basics/"},{"categories":["爱记录爱整理"],"content":"Ubuntu 20.10 服务器版安装记录","date":"2020-10-30","objectID":"/ubuntu_install/","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"安装界面 ","date":"2020-10-30","objectID":"/ubuntu_install/:1:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"语言选择 ","date":"2020-10-30","objectID":"/ubuntu_install/:2:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"键盘选择 ","date":"2020-10-30","objectID":"/ubuntu_install/:3:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"IPv4地址设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:4:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"IPv6地址设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:5:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"保存IP地址设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:6:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"代理地址设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:7:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"镜像源设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:8:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"磁盘设置 ","date":"2020-10-30","objectID":"/ubuntu_install/:9:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"删除LV重置 ","date":"2020-10-30","objectID":"/ubuntu_install/:9:1","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"创建分区 ","date":"2020-10-30","objectID":"/ubuntu_install/:10:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"创建swap分区 ","date":"2020-10-30","objectID":"/ubuntu_install/:10:1","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"创建根目录 ","date":"2020-10-30","objectID":"/ubuntu_install/:10:2","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"保存配置 ","date":"2020-10-30","objectID":"/ubuntu_install/:10:3","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"设置用户 ","date":"2020-10-30","objectID":"/ubuntu_install/:11:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"安装SSH服务 ","date":"2020-10-30","objectID":"/ubuntu_install/:12:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"进入安装界面 ","date":"2020-10-30","objectID":"/ubuntu_install/:13:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"安装完成重启 ","date":"2020-10-30","objectID":"/ubuntu_install/:14:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"移除光盘介质回车确认 ","date":"2020-10-30","objectID":"/ubuntu_install/:15:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱记录爱整理"],"content":"安装完成进入系统 ","date":"2020-10-30","objectID":"/ubuntu_install/:16:0","tags":["Ubuntu"],"title":"Ubuntu 20.10 服务器版安装记录","uri":"/ubuntu_install/"},{"categories":["爱技术爱折腾"],"content":"「I/O 流」管道和重定向","date":"2020-10-01","objectID":"/shell-redirect/","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"I/O 流 shell 使用 3 种标准「I/O 流」，每种流与一种文件描述符相关联： stdout 是标准输出流，显示来自命令的输出。文件描述符为 1。 stderr 是标准错误流，显示来自命令的错误输出。文件描述符为 2。 stdin 是标准输入流，向命令提供输入。文件描述符为 0。 ","date":"2020-10-01","objectID":"/shell-redirect/:1:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"输出重定向 使用 \u003e\u003e 或 \u003e 将输出流重定向到文件。如果文件不存在则创建文件；如果文件已存在的话，\u003e 覆盖文件，\u003e\u003e 附加文本到文件。例如： echo \"some text\" \u003e foo.txt echo \"append\" \u003e\u003e foo.txt ps \u003e\u003e ps.output 上面是将 stdout 重定向到文件，下面演示对 stderr 的处理： $ ls /usr \u003e output.txt $ $ # 报错的输出是 stderr，它不同于 stdout $ ls /not-exist \u003e output.txt ls: cannot access '/not-exist': No such file or directory $ $ # stdout 和 stderr 重定向到不同文件 $ ls /usr /not-exist \u003e stdout.txt 2\u003e stderr.txt $ $ cat stderr.txt ls: cannot access '/not-exist': No such file or directory $ $ # stdout 和 stderr 都输出到一个文件，下面两条命令效果一样 $ ls /usr /not-exist \u0026\u003e output.txt $ ls /usr /not-exist \u003e output.txt 2\u003e\u00261 $ cat output.txt ls: cannot access '/not-exist': No such file or directory /usr: bin lib local ... 上例中 2\u003e\u00261，2 和 1 分别是 stderr 和 stdout，即将 stderr 重定向到 stdout。ls /usr /not-exist \u003e output.txt 2\u003e\u00261 这一行的意思是将 stdout 重定向到 output.txt，且 stderr 重定向到 stdout，即全部重定向到文件。如果写成 2\u003e1 则表示 stderr 重定向到 1 这个文件，所以有了 2\u003e\u00261 这样特别的语法。 ","date":"2020-10-01","objectID":"/shell-redirect/:2:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"屏蔽输出 屏蔽输出只需要重定向到 /dev/null，例如： $ ls /not-exist ls: cannot access '/not-exist': No such file or directory $ $ # 屏蔽 stderr $ ls /not-exist 2\u003e /dev/null $ $ # 屏蔽所有输出 $ ls /usr /not-exist \u0026\u003e /dev/null ","date":"2020-10-01","objectID":"/shell-redirect/:2:1","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"输入重定向 我们先来看一个输入重定向的例子： $ sort \u003c\u003cEOF \u003e beef \u003e cheese \u003e apple \u003e EOF apple beef cheese sort 命令用于对问本行进行排序，可以从文件读取文本，也可以从 stdin 读取文本。\u003c\u003cEOF 表示前面的命令将从 stdin 读取文本，接下来终端显示提示符 \u003e 表示用户可以输入文本，最后敲 EOF 结束重定向 (EOF 可以替换为其他字符，开始和结束标记必须保持一样)。 另一个普遍的用途就是一次性写入多行文本到文件，例如写入一个 foo.txt 文件： cat \u003e foo.txt \u003c\u003cEOF This is line one. This is line two. EOF # 另一种写法 cat \u003c\u003cEOF \u003e foo.txt This is line one. This is line two. EOF ","date":"2020-10-01","objectID":"/shell-redirect/:3:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"管道 管道符号 |（英文名：pipeline）可以将多个命令串联起来，每一个进程的 stdout 作为下一个进程的 stdin，在 shell 中使用频率很高。比如一个命令输出的内容很多，我们可以用管道加上 more 便可以分页阅读，或者使用 grep 进行过滤。 ps -ef | more ps -ef | head ps -ef | grep init # 排序去重并统计行数 cat file | sort | uniq | wc-l sort 排序、uniq 去重、wc -l 统计行数，这些都是 shell 常用的命令，用管道组合各种命令将更奇妙。 ","date":"2020-10-01","objectID":"/shell-redirect/:4:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"tee 命令 tee 经常与管道组合起来使用，可在 stdout 正常输出的同时另外保存一份到文件。例如将 ping 得到的结果保存到文件： $ ping -c 3 www.baidu.com | tee ping.log PING www.a.shifen.com (180.101.49.11) 56(84) bytes of data. 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=1 ttl=52 time=17.1 ms 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=2 ttl=52 time=19.4 ms 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=3 ttl=52 time=16.7 ms --- www.a.shifen.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 5ms rtt min/avg/max/mdev = 16.736/17.737/19.396/1.186 ms $ $ cat ping.log PING www.a.shifen.com (180.101.49.11) 56(84) bytes of data. 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=1 ttl=52 time=17.1 ms ... tee 每次覆盖文件，tee -a 可附加文本到文件。 ","date":"2020-10-01","objectID":"/shell-redirect/:5:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"重定向和 sudo 正常的重定向无法配合 sudo 使用，解决的方法是通过 root 调用一个子 shell，在这个子 shell 里面进行重定向。例如： $ sudo echo \"some text\" \u003e\u003e /root/foo.txt bash: /root/foo.txt: 权限不够 $ $ sudo bash -c 'echo \"some text\" \u003e\u003e /root/foo.txt' $ sudo cat /root/foo.txt some text 另外 tee 命令可以与 sudo 配合使用，例如： $ echo \"append\" | sudo tee -a /root/foo.txt append $ sudo cat /root/foo.txt some text append $ # tee 写入文件并将 stdout 屏蔽 $ echo \"append again\" | sudo tee -a /root/foo.txt \u003e /dev/null !!! warning 把文件覆盖了就等于删除了，所以这类操作要小心，追加写入使用 \u003e\u003e、tee -a ","date":"2020-10-01","objectID":"/shell-redirect/:6:0","tags":["linux基础"],"title":"「I/O 流」管道和重定向","uri":"/shell-redirect/"},{"categories":["爱技术爱折腾"],"content":"bash 常用快捷键","date":"2020-10-01","objectID":"/shell-shortcuts/","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"快捷键可以帮助我们轻松操作 shell，例如 Ctrl + A 使光标移动到行首。有时候无意按下一组快捷键却不知情则会很苦恼，例如 Ctrl + S 会暂停终端输出，Ctrl + Z 会暂停当前的前台进程。所以掌握一部分常用快捷键是很有必要的。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:0:0","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"快捷键注意事项 当快捷键不能用时，有两个地方需要检查： 是否存在快捷键冲突 终端程序的键盘设置 !!! note “「Alt 组合键」替代方案” 「Alt 组合键」经常与终端程序冲突，可以使用 Esc 替代，例如 Alt + F 改为先按一次 Esc 再按 F ","date":"2020-10-01","objectID":"/shell-shortcuts/:1:0","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"编辑命令行 ","date":"2020-10-01","objectID":"/shell-shortcuts/:2:0","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"移动光标 Ctrl + A 移动到行首。 Ctrl + E 移动到行尾。 Alt + F 向前移动一个单词。 Alt + B 向后移动一个单词。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:2:1","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"删除字符 Alt + Del 删除从光标到单词开头 (如果不可用请尝试 Alt + Backspace，或者检查终端程序快捷键设置)。 Alt + D 删除从光标到单词末尾。 Ctrl + K 删除到行尾。 Ctrl + W 删除从光标到前面的空格。 Ctrl + Y 将最近一次删除的字符在光标的位置粘贴。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:2:2","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"历史命令 ↑ 调出上一个命令，持续按 ↑ / ↓ 在历史命令中切换。 Ctrl + R 在历史命令中搜索，搜索中继续按 Ctrl + R 向前翻。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:2:3","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"控制进程 Ctrl + C 中断当前的前台进程。 Ctrl + Z 暂停当前的前台进程。可使用 fg 命令继续运行。 Ctrl + D “end-of-file” (EOF)，当一行中没有任何字符时 Ctrl + D 被识别为 EOF。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:3:0","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"管理终端输出 Ctrl + L 清除屏幕。 Ctrl + S 暂停终端输出。 Ctrl + Q 恢复终端输出。 ","date":"2020-10-01","objectID":"/shell-shortcuts/:4:0","tags":["linux基础"],"title":"bash 常用快捷键","uri":"/shell-shortcuts/"},{"categories":["爱技术爱折腾"],"content":"bash 循环语句","date":"2020-10-01","objectID":"/shell-loop/","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"下面演示在 bash 中用不同的方法实现 5 次循环： for i in 1 2 3 4 5; do echo $i; done for i in {1..5}; do echo $i; done for i in $(seq 1 5); do echo $i; done for ((i=1; i\u003c=5; i++)); do echo $i; done i=1; while ((i \u003c= 5)); do echo $i; ((i++)); done i=1; until ((i \u003e 5)); do echo $i; ((i++)); done ","date":"2020-10-01","objectID":"/shell-loop/:0:0","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"for for 可用于遍历列表，每次迭代可执行一组命令。例如： $ for i in 1 2 3 4 5; do echo $i; done 1 2 3 4 5 $ for i in {1..5}; do echo $i; done 1 2 3 4 5 $ for i in $(seq 1 5); do echo $i; done 1 2 3 4 5 $ for i in bash dash zsh; do echo $i shell; done bash shell dash shell zsh shell for 循环可以通过多种途径获取列表，直接提供或者从命令获取，此外还可以提供连续的数字和字母列表 {1..5} {a..z}。 ","date":"2020-10-01","objectID":"/shell-loop/:1:0","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"遍历目录 /etc/profile 中有一段 for 循环，它在 /etc/profile.d/ 中遍历 *.sh 文件： for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done ","date":"2020-10-01","objectID":"/shell-loop/:1:1","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"C 语言风格 bash 提供类似 C 语言风格的 for 循环，请看下面的例子： for ((i=1; i\u003c=5; i++)); do echo $i; done ((i=1; i\u003c=5; i++)) 双括号中有 3 个算术表达式。第 1 个表达式只执行一次，起到初始化的作用；第 2 个是条件表达式，条件为真则继续循环；第 3 个表达式每次循环执行一次。每个表达式都可以省略，但是 2 个分号不能少，例如： i=1; for ((; i\u003c=5;)); do echo $i; ((i++)); done 中间那个条件表达式如果省略了，则无限循环。 ","date":"2020-10-01","objectID":"/shell-loop/:1:2","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"while \u0026 until for ((; i\u003c=5;)) 这样的 for 循环可以用 while 或 until 代替，下面这几种写法效果一样： i=1; for ((; i\u003c=5;)); do echo $i; ((i++)); done i=1; while ((i\u003c=5)); do echo $i; ((i++)); done i=1; until ((i\u003e5)); do echo $i; ((i++)); done while 在测试条件为真的时候循环，until 在测试条件为假的时候循环，它们的区别仅此而已。 ","date":"2020-10-01","objectID":"/shell-loop/:2:0","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"while 逐行处理文本 while 用于逐行处理文本比较方便，例如： $ cat \u003e test.list \u003c\u003cEOF 119.29.29.29 223.5.5.5 10.7.8.9 EOF $ cat test.list | while read line; do ping -c 1 $line \u0026\u003e /dev/null || echo $line offline; done 10.7.8.9 offline ","date":"2020-10-01","objectID":"/shell-loop/:2:1","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"break \u0026 continue 对于循环语句 for while until 和 select，可以适当控制其流程。break 退出整个循环，continue 跳到下一次循环，请看下面的例子： $ for i in {1..5}; do ((i==4)) \u0026\u0026 break; echo $i; done 1 2 3 $ for i in {1..5}; do ((i==4)) \u0026\u0026 continue; echo $i; done 1 2 3 5 上面是两个 for 循环的例子，循环 5 次，在第 4 次循环时分别执行 break 和 continue。break 退出整个循环，而 continue 跳出第 4 次循环。 ","date":"2020-10-01","objectID":"/shell-loop/:3:0","tags":["linux基础"],"title":"bash 循环语句","uri":"/shell-loop/"},{"categories":["爱技术爱折腾"],"content":"chmod 修改文件权限","date":"2020-10-01","objectID":"/chmod/","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"chmod - change file mode bits chmod 用于修改文件权限，普通用户可以修改自己的文件权限，root 可以修改任意文件权限。 ","date":"2020-10-01","objectID":"/chmod/:0:0","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"语法 chmod [OPTION]... MODE[,MODE]... FILE... ","date":"2020-10-01","objectID":"/chmod/:1:0","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"chmod 符号模式 符号模式看上去非常直观，下面是几个简单的例子： # 设置所有用户可读写 chmod a=rw file # 清空其他用户的写权限 chmod o-w file # 增加 onwer 执行权限 chmod u+x file # owner 可读写，group 和其他用户没有权限 chmod u=rw,go= file 符号模式有三个部分，分别是用户、操作符和权限，可以使用如下字符： [ugoa][+-=][rwxXst] 用户部分： u user (onwer) g group o 其他用户 a 所有用户，等同于 ugo 操作符： + 增加新权限 - 删除已有权限 = 修改权限，= 后面留空表示修改后的权限为空 权限部分可以使用常规的权限符号 rwx，和特殊权限符号 st。另外还可以使用大写 X 代替小写 x。大写 X 只对目录和已有执行权限的文件有效果，请看下面的例子： $ mkdir foo; touch foo.txt $ chmod o-x foo foo.txt $ ls -l drwxr-xr-- 2 linux-20 linux-20 4096 1月 17 13:56 foo -rw-r--r-- 1 linux-20 linux-20 0 1月 17 15:34 foo.txt $ $ chmod o+X foo foo.txt $ ls -l drwxr-xr-x 2 linux-20 linux-20 4096 1月 17 13:56 foo -rw-r--r-- 1 linux-20 linux-20 0 1月 17 15:34 foo.txt 上例中，对于目录文件 foo，o+X 等于 o+x；而对于没有执行权限的普通文件 foo.txt，o+X 没有效果。 ","date":"2020-10-01","objectID":"/chmod/:2:0","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"chmod 数字模式 数字模式是一种替代方案，下面是一个简单的例子： # 将文件设置为 owner 可读写，其他用户具有只读权限 chmod 644 file 数字模式需要将权限位转换为对应的数值，请看下面的对应关系： 数值 权限 4000 Set user ID 2000 Set group ID 1000 防删标记 # owner： 400 读 200 写 100 执行 # group: 40 读 20 写 10 执行 # 其他用户： 4 读 2 写 1 执行 需要哪些权限，就将对应的数值累加起来。比如 owner 读和写，group 读，其他用户读，即 400 + 200 + 40 + 4 = 644。 实践案例： $ mkdir foo private public $ # private 目录，只有 onwer 具有权限 $ chmod 0700 private $ # public 目录，所有用户具有权限，但只有 owner 可删除 $ chmod 1777 public $ ls -l 总用量 12 drwxr-xr-x 2 linux-20 linux-20 4096 1月 18 13:36 foo drwx------ 2 linux-20 linux-20 4096 1月 18 13:36 private drwxrwxrwt 2 linux-20 linux-20 4096 1月 18 13:36 public ","date":"2020-10-01","objectID":"/chmod/:3:0","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"目录递归 修改目录权限时，默认只对目录本身有效，目录下的文件不受影响。chmod -R 递归修改目录下所有文件和子文件夹的权限。 $ mkdir -p private/foo $ touch private/foo.txt $ chmod -R u=rwX,go= private $ ls -l private drwx------ 2 linux-20 linux-20 4096 1月 18 14:32 foo -rw------- 1 linux-20 linux-20 0 1月 18 14:32 foo.txt 上例中创建了一个私有目录 private，并设置 owner 具有读写权限，其他用户不能访问。这里使用了 u=rwX，即目录具有 rwx 权限，而普通文件具有 rw- 权限。通过这个例子我们看到，递归修改目录权限时，使用大写 X 比较合适。 ","date":"2020-10-01","objectID":"/chmod/:4:0","tags":["linux基础"],"title":"chmod 修改文件权限","uri":"/chmod/"},{"categories":["爱技术爱折腾"],"content":"chown 修改文件归属","date":"2020-10-01","objectID":"/chown/","tags":["linux基础"],"title":"chown 修改文件归属","uri":"/chown/"},{"categories":["爱技术爱折腾"],"content":"chown - change file owner and group chown 用于修改文件归属的用户和组 (owner 和 group)，需要注意： root 用户可以修改文件 owner 和 group。 文件 owner 可以将 group 修改为他所属的任意一个组。 !!! note 修改文件 owner 需要 root 权限。 ","date":"2020-10-01","objectID":"/chown/:0:0","tags":["linux基础"],"title":"chown 修改文件归属","uri":"/chown/"},{"categories":["爱技术爱折腾"],"content":"语法 chown [OPTION]... [OWNER][:[GROUP]] FILE... -R 选项用于递归修改目录。 ","date":"2020-10-01","objectID":"/chown/:1:0","tags":["linux基础"],"title":"chown 修改文件归属","uri":"/chown/"},{"categories":["爱技术爱折腾"],"content":"chown 案例 # 修改文件 owner 和 group sudo chown root:root file # 仅修改文件 owner sudo chown root file # 仅修改文件 group sudo chown :root file # 用户拥有 foo 文件，并且他属于 group-a 组时，可以这样修改 chown :group-a foo # 在 /var/www 创建一个站点目录，并修改目录归属 sudo mkdir -p /var/www/foo-site sudo chown -R www-data:www-data /var/www/foo-site ","date":"2020-10-01","objectID":"/chown/:2:0","tags":["linux基础"],"title":"chown 修改文件归属","uri":"/chown/"},{"categories":["爱技术爱折腾"],"content":"chgrp chgrp 也可以用来修改文件 group，例如： # 下面两条命令效果一样 chgrp root file chown :root file ","date":"2020-10-01","objectID":"/chown/:3:0","tags":["linux基础"],"title":"chown 修改文件归属","uri":"/chown/"},{"categories":["爱技术爱折腾"],"content":"dpkg 管理软件包","date":"2020-10-01","objectID":"/dpkg/","tags":["linux基础"],"title":"dpkg 管理软件包","uri":"/dpkg/"},{"categories":["爱技术爱折腾"],"content":"安装软件 dpkg 也可用于安装软件，例如安装 chrome 浏览器： 下载 $ curl -L -o chrome.deb https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 安装 $ sudo dpkg -i chrome.deb 卸载 $ sudo dpkg -r chrome ","date":"2020-10-01","objectID":"/dpkg/:1:0","tags":["linux基础"],"title":"dpkg 管理软件包","uri":"/dpkg/"},{"categories":["爱技术爱折腾"],"content":"查看已安装的软件包 dpkg -l 可查看已安装的软件包，因为输出信息较多，一般使用 grep 进行过滤，例如： $ dpkg -l | grep docker ii docker-ce 5:19.03.7~3-0~debian-buster amd64 Docker: the open-source application container engine ii docker-ce-cli 5:19.03.7~3-0~debian-buster amd64 Docker CLI: the open-source application container engine ii docker-compose 1.21.0-3 all Punctual, lightweight development environments using Docker rc docker.io 18.09.1+dfsg1-7.1+deb10u1 amd64 Linux container runtime 上面的输出信息中，以 ii 开头的是已安装的包，rc 开头表示该软件包已经被移除但是遗留了配置文件。 ","date":"2020-10-01","objectID":"/dpkg/:2:0","tags":["linux基础"],"title":"dpkg 管理软件包","uri":"/dpkg/"},{"categories":["爱技术爱折腾"],"content":"根据文件查询相关联的软件包 dpkg -S 可查询文件相关联的软件包。如果我主机上可用的命令在云主机上用不了，而且我也不清楚应该安装哪个包，此时就可以使用 dpkg -S 进行查询。 $ which ip /bin/ip $ dpkg -S /bin/ip iproute2: /bin/ip $ $ dpkg -S $(which ss) iproute2: /bin/ss $ dpkg -S $(which top) procps: /usr/bin/top $ dpkg -S $(which dig) dnsutils: /usr/bin/dig ","date":"2020-10-01","objectID":"/dpkg/:3:0","tags":["linux基础"],"title":"dpkg 管理软件包","uri":"/dpkg/"},{"categories":["爱技术爱折腾"],"content":"重置软件包配置 dpkg-reconfigure 用于重新配置已安装的软件包，例如重新配置语言环境、时区等： 重新配置语言环境 $ sudo dpkg-reconfigure locales 重新配置时区 $ sudo dpkg-reconfigure tzdata ","date":"2020-10-01","objectID":"/dpkg/:4:0","tags":["linux基础"],"title":"dpkg 管理软件包","uri":"/dpkg/"},{"categories":["爱技术爱折腾"],"content":"gawk 基础用法","date":"2020-10-01","objectID":"/awk/","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"awk 是一款用于处理文本的编程语言工具。它提供了比较强大的功能：可以进行正则表达式的匹配，流控制、数学运算符、进程控制语句还有内置的变量和函数。 gawk 即 GNU awk，是许多 Linux 发行版默认的 awk 程序。 ","date":"2020-10-01","objectID":"/awk/:0:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"安装 sudo apt install gawk ","date":"2020-10-01","objectID":"/awk/:1:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"gawk 正则表达式 gawk 使用 ERE 语法，与 grep ERE 语法 基本一致，有两点需要注意： awk 正则表达式写在 2 个 / 中间，书写普通斜杠符号需要加转义字符：\\/。 因为 \\b 在 awk 语言里被定义为 backspace，所以 gawk 使用 \\y 代替 \\b 作为锚点符号，匹配单词的边缘。 ","date":"2020-10-01","objectID":"/awk/:2:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"gawk 代替 grep 和 sed gawk 可以用于文本搜索和文本替换，一定程度上可代替 grep 和 sed，请看下面的例子。 用于文本搜索： # 查看发行版 cat /etc/os-release | gawk '/PRETTY/' cat /etc/os-release | grep 'PRETTY' # 过滤注释行或空白行 cat ~/.profile | gawk '!/^\\s*(#|$)/' cat ~/.profile | egrep -v '^\\s*(#|$)' 用于文本替换： $ echo \"A beautiful girl\" | gawk '{gsub(/girl/,\"woman\"); print $0}' A beautiful woman $ $ echo \"A beautiful girl\" | sed 's/girl/woman/' A beautiful woman gawk 是比较全能的文本处理工具，但是在一些基本的用途中，其简洁性不如 grep 和 sed，如何选择则根据个人习惯。 ","date":"2020-10-01","objectID":"/awk/:3:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"字段分割 awk 根据字段分割符划分文本行，并将如下变量分配给数据字段： $0 代表整行文本 $1 代表行中的第 1 个数据字段 $2 代表行中的第 2 个数据字段 $n 代表行中的第 n 个数据字段 默认的分割符是空格或者制表符，可以使用 -F 选项指定分割符，请看下面的例子： # 使用默认分割符，打印第二个字段 cat /etc/apt/sources.list | gawk '{print $2}' # 指定分割符，打印第一个字段 cat /etc/passwd | gawk -F : '{print $1}' ","date":"2020-10-01","objectID":"/awk/:4:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"按指定数据字段进行匹配 awk 可以指定数据字段进行文本匹配，而不是整行匹配，请看下面的例子： # 搜索包含 bin 的行 cat /etc/passwd | gawk -F : '/bin/' # 搜索第一个字段包含 bin 的行，即用户名包含 bin cat /etc/passwd | gawk -F : '$1 ~ /bin/' ","date":"2020-10-01","objectID":"/awk/:4:1","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"数学表达式 数学表达式支持 == \u003e \u003e= \u003c \u003c= 这些数学符号，例如： # 找出 uid 大于等于 1000 的用户 cat /etc/passwd | gawk -F : '$3 \u003e= 1000' == 也可以用于字符串精确匹配，例如： # 使用数学表达式找出 bin 用户 cat /etc/passwd | gawk -F : '$1 == \"bin\"' # 使用正则表达式找出 bin 用户 cat /etc/passwd | gawk -F : '$1 ~ /^bin$/' ","date":"2020-10-01","objectID":"/awk/:5:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"布尔表达式 布尔操作符 || (or), \u0026\u0026 (and), ! (not), 例如： # 大于等于 1000 或等于 0 cat /etc/passwd | gawk -F : '$3 \u003e= 1000 || $3 == 0' # 大于等于 1000 或且小于 2000 cat /etc/passwd | gawk -F : '$3 \u003e= 1000 \u0026\u0026 $3 \u003c 2000' # 不小于 1000 cat /etc/passwd | gawk -F : '!($3 \u003c 1000)' # 不匹配三位数及以下 cat /etc/passwd | gawk -F : '$3 !~ /^[0-9]{1,3}$/' ","date":"2020-10-01","objectID":"/awk/:6:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"printf 格式化打印 printf 支持更灵活的打印输出，例如： # 按指定宽度打印用户名和 uid，实现等宽排列 cat /etc/passwd | gawk -F : '{printf \"%-20s %5s\\n\", $1, $3}' 将得到用户名和 uid 整齐的输出格式，如下所示： root 0 daemon 1 nobody 65534 systemd-timesync 100 systemd-network 101 gawk 中 printf 的用法跟C语言一样: printf \"%-20s %5s\\n\", $1, $3 这个例子中 2 个 %s 是字符串指示符，输出时被后面对应位置的变量替换，中间的数字 20 和 5 代表输出字段的最小宽度，默认右对其，数字前加 - 代表左对其。 下面再看一个例子： cat /etc/group | gawk -F : '{printf \"%-20s %-10s Members: %s\\n\", $1, $3, $4}' 将得到组名，gid，组成员整齐的输出格式，如下所示： root 0 Members: ssl-cert 109 Members: postgres scanner 119 Members: saned,jack docker 130 Members: jack ","date":"2020-10-01","objectID":"/awk/:7:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"awk 语法 运行 awk： # 命令行运行 awk 'program' input-file1 input-file2 … # 从程序源文件运行，使用 -f 选项 awk -f program-file input-file1 input-file2 … awk program 格式： pattern { action } pattern { action } … 案例： # 以下几种写法效果一样 awk -F : '$3 \u003e= 1000 {print}' /etc/passwd cat /etc/passwd | gawk -F : '$3 \u003e= 1000 {print}' cat /etc/passwd | gawk -F : '$3 \u003e= 1000 {print $0}' # {print} 等同于 {print $0}，可省略不写 cat /etc/passwd | gawk -F : '$3 \u003e= 1000' ","date":"2020-10-01","objectID":"/awk/:8:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"awk 其他进阶用法 # if 语句 cat /etc/passwd | gawk -F : '{if ($1 == \"bin\") print $0}' # 调用 shell 环境变量 cat /etc/passwd | gawk -F : '{if ($1 == ENVIRON[\"USER\"]) print $0}' # 字符函数，转换为小写字母 cat /etc/os-release | gawk 'tolower($0) ~ /pretty/' env | gawk '{print tolower($0)}' ","date":"2020-10-01","objectID":"/awk/:9:0","tags":["linux基础"],"title":"gawk 基础用法","uri":"/awk/"},{"categories":["爱技术爱折腾"],"content":"GNU nano","date":"2020-10-01","objectID":"/nano/","tags":["linux基础"],"title":"GNU nano","uri":"/nano/"},{"categories":["爱技术爱折腾"],"content":"流行的命令行文本编辑器有 vim、emacs、nano，其中 vim 和 emacs 具有一定的上手难度同时也更强大。nano 比较小巧并且上手难度低，非常适合轻度需求的用户。 GNU nano 3.2 /etc/apt/sources.list Modified deb http://mirrors.aliyun.com/debian buster main deb-src http://mirrors.aliyun.com/debian buster main deb http://mirrors.aliyun.com/debian-security/ buster/updates main deb-src http://mirrors.aliyun.com/debian-security/ buster/updates main deb http://mirrors.aliyun.com/debian buster-updates main deb-src http://mirrors.aliyun.com/debian buster-updates main ^G Get Help ^O Write Out ^W Where Is ^K Cut Text ^J Justify ^X Exit ^R Read File ^\\ Replace ^U Uncut Text ^T To Spell 上面是 nano 「主编辑界面」，第一行显示程序版本、编辑的文件和是否被修改，最后两行显示常用的快捷键，倒数第三行会显示重要的消息。编辑完成后按 Ctrl + S 保存，按 Ctrl + X 退出。 ","date":"2020-10-01","objectID":"/nano/:0:0","tags":["linux基础"],"title":"GNU nano","uri":"/nano/"},{"categories":["爱技术爱折腾"],"content":"快捷键 nano 完全使用键盘操作，界面底部显示部分常用快捷键，进入帮助页面 ( Ctrl + G ) 可查看更多。快捷键有「控制组合键」和「Meta 组合键」两种： 「控制组合键」使用 Ctrl，在帮助文档里显示 ^。例如 ^X (退出操作) 同时按下 Ctrl + X。 「Meta 组合键」使用 Alt，在帮助文档里显示 M-。例如 M-U (撤销操作) 同时按下 Alt + U。 当 Ctrl 或 Alt 组合键不能工作时，可以使用 Esc 代替。「控制组合键」按 2 次 Esc 再按目标按键；「Meta 组合键」按 1 次 Esc 再按目标按键。例如 “GNOME terminal” 使用 Alt + 数字 切换标签，这时 nano 使用 Alt + 6 进行复制操作将会冲突，可以先按 Esc 再按 6 进行复制。 !!! note “当心 Esc” 按下 Esc 后编辑器进入非正常模式，接下来不可随意按其他键，要想恢复到正常的输入模式可以按 Ctrl + C。当无意按下 Esc 后需要特别注意。 ","date":"2020-10-01","objectID":"/nano/:1:0","tags":["linux基础"],"title":"GNU nano","uri":"/nano/"},{"categories":["爱技术爱折腾"],"content":"快捷键参考 下列快捷键可用于「主编辑界面」： 操作文件 Ctrl + S 保存文件 Ctrl + O 文件另存为 Ctrl + X 退出文件 编辑 Ctrl + K 剪切 (当前行或者被标记的区域) Alt + 6 复制 (当前行或者被标记的区域) Alt + A 开始或结束标记 Ctrl + U 粘贴 Ctrl + Shift + Del 删除左边的单词 Ctrl + Del 删除右边的单词 Alt + Del 删除 (当前行或者被标记的区域) Alt + U 撤销上一次动作 Ctrl + E 恢复撤销的动作 搜索和替换 Ctrl + W 开始正向搜索 Ctrl + Q 开始反向搜索 Alt + W 向后搜索下一个匹配 Alt + Q 向前搜索下一个匹配 Ctrl + \u003c/kbd\u003e ( Alt + R ) 替换 移动光标 Ctrl + → 向后跳动一个单词 Ctrl + ← 向前跳动一个单词 Ctrl + A 跳到行首 Ctrl + E 跳到行尾 Ctrl + Y ( PageUp ) 跳到上一页 Ctrl + V ( PageDown ) 跳到下一页 Ctrl + \u003c/kbd\u003e ( Ctrl + HOME ) 跳到第一行 Ctrl + / ( Ctrl + END ) 跳到最后一行 帮助 Ctrl + C 报告光标位置 Ctrl + G 查看帮助 !!! note 在不同界面快捷键的作用会有差别，比如进入搜索界面时可以开启正则表达式匹配，注意底部显示的常用快捷键，另外在不同界面按 Ctrl + G 会得到不同的帮助信息。 ","date":"2020-10-01","objectID":"/nano/:1:1","tags":["linux基础"],"title":"GNU nano","uri":"/nano/"},{"categories":["爱技术爱折腾"],"content":"正则表达式搜索 nano 支持「扩展正则表达式」(ERE) 进行搜索，其规则与 egrep 一致。 ","date":"2020-10-01","objectID":"/nano/:2:0","tags":["linux基础"],"title":"GNU nano","uri":"/nano/"},{"categories":["爱技术爱折腾"],"content":"grep 与正则表达式","date":"2020-10-01","objectID":"/grep-regexp/","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep 是一款非常流行的文本搜索工具，它根据正则表达式对文本进行搜索，并输出匹配的行或文本。 ","date":"2020-10-01","objectID":"/grep-regexp/:0:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep 典型案例 # 查看发行版 cat /etc/os-release | grep 'PRETTY' # 查看 CPU 型号 cat /proc/cpuinfo | grep 'model name' # 查看内核参数 sudo sysctl -a | grep 'swap' 得到如下输出： $ # 查看发行版 $ cat /etc/os-release | grep 'PRETTY' PRETTY_NAME=\"Debian GNU/Linux 10 (buster)\" $ $ # 查看 CPU 型号 $ cat /proc/cpuinfo | grep 'model name' model name : Intel(R) Core(TM) i7-5500U CPU @ 2.40GHz $ $ # 查看内核参数 $ sudo sysctl -a | grep 'swap' vm.swappiness = 60 ","date":"2020-10-01","objectID":"/grep-regexp/:1:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"正则表达式 grep '.sh' 这个表达式就超出了字面的含义，请看下面这个例子： $ ls -a ~ | grep '.sh' .bashrc setup.sh .ssh $ ls -a ~ | grep '\\.sh' setup.sh grep 使用正则表达式进行匹配，因为 . 在正则表达式里有特殊含义，它匹配一个任意字符，所以 .ssh .bashrc 文件也匹配到了。 正则表达式是使用 grep 的基础，它有不同规范，下面将介绍 Linux 中常见的 ERE 和 BRE。 ","date":"2020-10-01","objectID":"/grep-regexp/:2:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"ERE 和 BRE 简称 全称 解释 BRE basic regular expressions 基础正则表达式 (过时的) ERE extended regular expressions 扩展正则表达式 (现代的) 如果从字面理解，基础这个字眼让 BRE 显得具有一定地位，但实质上 BRE 的存在只是为了兼容一些老旧的软件。 GNU grep 对 BRE 和 ERE 进行了扩展，使得它们之间的差别很小，那就是转义字符的使用: ? + | { } ( ) \\? \\+ \\| \\{ \\} \\( \\) BRE 中前者表示字面量，后者具有特殊含义。而 ERE 则相反，前者具有特殊含义，后者表示字面量。例如列出文件名以 config 或者 conf 或者 cfg 结尾的文件： # 使用 ERE ls -a | grep -E '(config|conf|cfg)$' # 使用 BRE ls -a | grep '\\(config\\|conf\\|cfg\\)$' !!! note GNU grep 对 BRE 进行了扩展，它并不完全符合 POSIX 规范。在 POSIX 规范中 BRE 不支持 \\?、\\+、\\| 这些元字符。 ","date":"2020-10-01","objectID":"/grep-regexp/:3:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"推荐使用 ERE ERE 的风格被现代应用程序广泛支持，推荐使用 ERE。 grep 默认使用 BRE，grep -E 或者 egrep 使用 ERE sed 默认使用 BRE，sed -E 使用 ERE gawk 使用 ERE egrep 等同于 grep -E，下文将统一使用 egrep。 ","date":"2020-10-01","objectID":"/grep-regexp/:4:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep ERE 语法 ","date":"2020-10-01","objectID":"/grep-regexp/:5:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"转义字符 转义字符 \\ 指示后面的字符具有特殊含义或者恢复该字符的字面量。本身具有特殊含义的字符前面加 \\ 则恢复字面量，例如 \\.。某些普通字符前面加 \\ 则具有特殊含义。 \\b \\B \\\u003c \\\u003e \\s \\S \\w \\W 这些符号具有特殊含义，下面马上就会介绍。POSIX ERE 规范中并不支持这些特殊符号，它们属于 GNU grep 的扩展。 ","date":"2020-10-01","objectID":"/grep-regexp/:5:1","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"字符集合 字符集合匹配一个属于集合中的字符。 字符集合 描述 表达式样例 . 匹配一个任意字符，包括换行符。 [ list ] 匹配一个在列表中的字符。 [RrB]ose 匹配 “Rose” “rose” “Bose” [^ list ] 匹配一个不在列表中的字符。 a[^0-9]c 匹配 “aFc” 不匹配 “a3c” \\s 匹配空白符 (空格、制表符和换行符)。 (GNU 扩展) \\S 匹配非空白符，与 \\s 相反。 (GNU 扩展) \\w 匹配单词字符 (英文字母或者数字)。 (GNU 扩展) \\W 匹配非单词字符，与 \\w 相反。 (GNU 扩展) ","date":"2020-10-01","objectID":"/grep-regexp/:5:2","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"数量符 数量符限定前面的实例匹配的次数。 数量符 描述 表达式样例 * 前面的实例匹配 0 次或多次。 ab*c 匹配 “ac” “abc” “abbc” + 前面的实例匹配 1 次或多次。 ? 前面的实例匹配 0 次或 1 次。 { n } 前面的实例匹配 n 次。 { n, } 前面的实例匹配 n 次或更多。 { n , m } 前面的实例匹配大于等于 n 次且小于等于 m 次。 ","date":"2020-10-01","objectID":"/grep-regexp/:5:3","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"锚点 锚点匹配一个定位。 锚点 描述 表达式样例 ^ 匹配一行开头 $ 匹配一行结尾 \\b 匹配单词边缘。 (GNU 扩展) good\\b 匹配 “good night” 不匹配 “goodbye” \\B 匹配非单词边缘，与 \\b 相反。 (GNU 扩展) \\\u003c 匹配单词开头。 (GNU 扩展) \\\u003e 匹配单词结尾。 (GNU 扩展) ","date":"2020-10-01","objectID":"/grep-regexp/:5:4","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"分组 符号 描述 表达式样例 ( ) 分割一个子表达式 a(bc){3} 匹配 “abcbcbc” ","date":"2020-10-01","objectID":"/grep-regexp/:5:5","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"或表达式 符号 描述 表达式样例 ` ` 匹配任意一个被 ` ","date":"2020-10-01","objectID":"/grep-regexp/:5:6","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep 常用选项 -E, –extended-regexp, 使用扩展正则表达式 (ERE) -i, –ignore-case, 忽略大小写 -v, –invert-match, 反选，即选择未匹配的行 -w, –word-regexp, 单词匹配模式 -r, –recursive, 递归读取整个目录的文件进行匹配 -o, –only-matching, 仅打印行中匹配的部分 -q, –quiet, –silent, 静默模式，一旦发现匹配即退出并返回状态码 0 ","date":"2020-10-01","objectID":"/grep-regexp/:6:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep 实践 ","date":"2020-10-01","objectID":"/grep-regexp/:7:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"文本搜索小游戏 例如有这样一个文件： I use Linux. Jack uses macOS. Most people choose Windows 10. [\"linux\", \"macos\", \"win10\"] 使用 grep 搜索指定的行，得到如下输出： $ # 搜索含有 macOS 的行，不区分大小写 $ egrep -i 'macos' file Jack uses macOS. [\"linux\", \"macos\", \"win10\"] $ $ # 搜索含有 use 的行 $ egrep 'use' file I use Linux. Jack uses macOS. $ $ # 搜索含有单词 use 的行 $ # 可以使用 \\b 界定单词的边缘 $ egrep '\\buse\\b' file I use Linux. $ # 也可以使用 grep -w 单词匹配模式 $ egrep -w 'use' file I use Linux. $ $ # 搜索含有 win10 或者 windows 10 或者 windows10 的行，不区分大小写 $ egrep -i '(win|windows |windows)10' file Most people choose Windows 10. [\"linux\", \"macos\", \"win10\"] $ egrep -i 'win(dows ?)?10' file Most people choose Windows 10. [\"linux\", \"macos\", \"win10\"] $ $ # 搜索 windows 后面带有两位数字的行，不区分大小写 $ egrep -i 'windows ?[0-9]{2}' file Most people choose Windows 10. ","date":"2020-10-01","objectID":"/grep-regexp/:7:1","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"文件名搜索 ls 与 grep 配合使用可以帮助我们列出指定类型的文件： # 列出所有 YAML 文件 (文件名以 .yaml 或者 .yml 结尾) ls -a | egrep '\\.ya?ml$' # 列出文件名以 config 或者 conf 或者 cfg 结尾的文件 ls -a | egrep '(config|conf|cfg)$' # 列出所有文件，过滤掉目录 ls -al | egrep '^-' # 列出 /etc 目录(包括子目录) 下文件名包含 release 的文件 sudo ls -alR /etc | egrep -i 'release' ","date":"2020-10-01","objectID":"/grep-regexp/:7:2","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"查看系统信息并过滤 # 查看 CPU 型号、内核数和线程数 cat /proc/cpuinfo | egrep 'model name|cpu cores|siblings' cat /proc/cpuinfo | egrep 'model name|cpu cores|siblings' | sort | uniq # \"| sort | uniq\" 排序并去重 # 查看 /etc/group 并搜索指定组 cat /etc/group | egrep '^groupname' cat /etc/group | egrep '^(sudo|docker)' # 查看内核参数 sudo sysctl -a | egrep 'swap' sudo sysctl -a | egrep 'tcp.*control' # 列出所有系统用户 cat /etc/passwd | egrep -o '^[^:]+' ","date":"2020-10-01","objectID":"/grep-regexp/:7:3","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"过滤注释行和空白行 查看配置文件时，为了一目了然，有时需要过滤掉注释行和空白行。假定以 # 开头的行属于注释行，若干空白符加 # 开头的也算。 正则表达式匹配注释行 ^\\s*# 和空白行 ^\\s*$，然后使用 -v 选项反选。合并在一起就是 egrep -v '^\\s*(#|$)'，例如： egrep -v '^\\s*(#|$)' ~/.profile ","date":"2020-10-01","objectID":"/grep-regexp/:7:4","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"日志搜索 下面是 apache httpd 日志的部分信息： 127.0.1.1:80 127.0.0.1 - - [09/Dec/2019:09:21:19 +0800] \"GET / HTTP/1.1\" ... 127.0.1.1:80 127.0.0.1 - - [09/Dec/2019:10:59:06 +0800] \"GET / HTTP/1.1\" ... 127.0.1.1:80 127.0.0.1 - - [09/Dec/2019:11:05:08 +0800] \"GET / HTTP/1.1\" ... 127.0.1.1:80 127.0.0.1 - - [10/Dec/2019:09:02:08 +0800] \"GET / HTTP/1.1\" ... 搜索指定时间段的日志： # 搜索某一天的日志egrep '^export EDITOR\\b' ~/.profile egrep '\\[09/Dec/2019:' file # 搜索某一天 10:00-11:59 之间的日志 egrep '\\[09/Dec/2019:1[0-1]' file ","date":"2020-10-01","objectID":"/grep-regexp/:7:5","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"目录搜索 grep -r 会递归读取整个目录进行匹配，下面看几个例子： # 在 /etc/apt 中搜索 vscode egrep -i 'vscode' -r /etc/apt # 在内核配置文件中搜索 ipv4 # 搜索范围包括 /etc/sysctl.conf 和 /etc/sysctl.d egrep -i 'ipv4' -r /etc/sysctl.d /etc/sysctl.conf # 将注释行也过滤掉 egrep -i '^\\s*[^#]*ipv4' -r /etc/sysctl.d /etc/sysctl.conf ","date":"2020-10-01","objectID":"/grep-regexp/:7:6","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"grep 串联 可以将多个 grep 进行串联以代替一个复杂的正则表达式，例如： # 搜索关键字再把注释行去掉 egrep 'ipv4' -r /etc/sysctl.d /etc/sysctl.conf | egrep -v '^\\s*#' ","date":"2020-10-01","objectID":"/grep-regexp/:8:0","tags":["linux基础"],"title":"grep 与正则表达式","uri":"/grep-regexp/"},{"categories":["爱技术爱折腾"],"content":"Linux 基础组件","date":"2020-10-01","objectID":"/linux/","tags":["linux基础"],"title":"Linux 基础组件","uri":"/linux/"},{"categories":["爱技术爱折腾"],"content":"Linux 核心的部分是「Linux 内核」，它就像硬壳中的种子一样存在于操作系统中，并且控制着硬件的所有主要功能。内核主要负责内存管理、进程管理、设备驱动和系统调用。 此外，安装在主机上的「Linux 操作系统」通常包含以下组件： bootloader，引导程序，比如 GRUB。它是将内核加载到内存的程序。 init，初始化程序，比如 systemd。内核加载完成后，首先启动 init 进程，接着由 init 完成后面的系统启动。 基础软件库，比如 glibc (GNU C Library)。 基础工具，比如 GNU coreutils，它提供 cat、ls、mkdir 等基础工具。 软件包管理系统，比如 dpkg 或 RPM，它用于安装、移除和管理软件包。 用户界面，比如 shell 或桌面环境。 以上这些组件中 GRUB、glibc、coreutils 和 bash shell 都属于 GNU 软件，因此有些人把这样的操作系统称为 GNU/Linux，以支持 GNU 的贡献。需要明确的是，Linux 不属于 GNU，Linux 生态中有很多贡献者，GNU 软件在很多 Linux 发行版中占比最大。 ","date":"2020-10-01","objectID":"/linux/:0:0","tags":["linux基础"],"title":"Linux 基础组件","uri":"/linux/"},{"categories":["爱技术爱折腾"],"content":"Linux 目录结构简介","date":"2020-10-01","objectID":"/linux-fhs/","tags":["linux基础"],"title":"Linux 目录结构简介","uri":"/linux-fhs/"},{"categories":["爱技术爱折腾"],"content":"什么文件存放在哪个目录，目录的结构如何组织，这在 Linux 上面是有规范的，下面简要介绍一下： 目录 描述 / 根目录 /bin 存放主要的二进制文件，例如 /bin/ls /bin/cat /sbin 类似 /bin，存放系统相关的二进制文件，多适用系统管理员，例如 /sbin/mkfs /usr 存放次要的只读数据 (这个目录很重要，并非字面意义的\"次要\") /usr/bin 存放二进制文件 (与 /bin 的区分比较模糊) /usr/local 存放本地数据，此目录下可以有 bin lib 等子目录 /opt 存放可选的应用程序软件包 /boot 存放 boot loader 文件 /dev 存放设备文件，例如 /dev/cdrom /dev/tty /lib 存放基础库文件，这是许多 bin 文件的依赖项 /etc 存放基础配置文件，例如 /etc/hosts /etc/profile /root root 用户主目录 /home 用户主目录，例如 /home/user01 /home/linux-20 /var 存放易变的数据 (某些特殊用户的主目录会放在这个目录下，例如 /var/mail) /var/lib 存放程序需要持久保存的数据，例如 database 数据文件 /var/log 存放日志文件 /tmp 存放临时文件，系统重启后不必保留 在今天看来，有些目录的用途与其名称是不匹配的，例如 /etc /usr。很多名称是早期定义的，一直沿用至今，但是其用途或许已经改变了。 ","date":"2020-10-01","objectID":"/linux-fhs/:0:0","tags":["linux基础"],"title":"Linux 目录结构简介","uri":"/linux-fhs/"},{"categories":["爱技术爱折腾"],"content":"linux基础","date":"2020-10-01","objectID":"/linux-base-summary/","tags":["linux基础"],"title":"linux基础目录","uri":"/linux-base-summary/"},{"categories":["爱技术爱折腾"],"content":" Linux 基础组件 1 bash shell 1.1 终端和 shell 1.2 选择 shell 1.3 基础命令简介 1.4 环境变量 1.5 shell 语法 1.6 shell 字符扩展 1.7 管道和重定向 1.8 shell 条件语句 1.9 shell 循环语句 1.10 执行文件 1.11 快捷键 2 文件权限 2.1 文件权限基础 2.2 chmod 修改文件权限 2.3 chown 修改文件归属 2.4 Linux 目录结构简介 3 文本编辑器 3.1 GNU nano 4 管理网络 4.1 配置网络 4.2 iproute2 5 管理软件包 5.1 使用 apt 安装软件 5.2 dpkg 6 管理用户和组 7 syst 7.1 syst 和 systemctl 7.2 基于 syst 部署服务 8 文本处理 8.1 grep 与正则表达式 8.2 sed 流编辑器 8.3 gawk 基础用法 ","date":"2020-10-01","objectID":"/linux-base-summary/:0:0","tags":["linux基础"],"title":"linux基础目录","uri":"/linux-base-summary/"},{"categories":["爱技术爱折腾"],"content":"sed 流编辑器","date":"2020-10-01","objectID":"/sed/","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"sed (stream editor) 即流编辑器，它读取输入流 (文件或来自管道的输入)，并依照一系列命令对内容进行编辑修改，最后将结果写入标准输出。 sed 是很老牌的文本处理工具，它逐渐被其它工具所取代，例如 awk。但由于 sed 的几个命令非常简洁易用，比如替换、插入和删除，所以它仍然广受喜爱。 一个简单的文本替换案例： $ # 使用 sed $ echo \"A beautiful girl\" | sed 's/girl/woman/' A beautiful woman $ $ # 使用 awk $ echo \"A beautiful girl\" | awk '{gsub(/girl/,\"woman\"); print $0}' A beautiful woman ","date":"2020-10-01","objectID":"/sed/:0:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"sed 常用选项 -E, –extended-regexp, 使用扩展正则表达式 (ERE) -e script, –expression=script, 添加 sed 执行的命令 -i[SUFFIX], –in-place[=SUFFIX], 直接修改文件，如果提供了 SUFFIX 将会备份 sed 对文本进行修改的命令，默认只会将输出打印出来，加上 -i 直接对文件进行修改，例如： # 将替换后的文本打印出来 sed 's/foo/bar/' file # 对文件进行文本替换 sed -i 's/foo/bar/' file # 对文件进行文本替换，将会创建一个备份文件 file.sed sed -i.sed 's/foo/bar/' file -i 与其它选项一起使用时应分开写，例如 -i -E 不能写成 -iE，请看下面的例子： # 下面两条命令是等价的 sed -Ei '...' file sed -E -i '...' file # -iE 等价于 --in-place=E，会创建一个备份文件 fileE sed -iE '...' file ","date":"2020-10-01","objectID":"/sed/:1:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"正则表达式 GNU sed -E 使用 ERE 语法，与 grep ERE 语法 一致。 ","date":"2020-10-01","objectID":"/sed/:2:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"替换命令语法 替换命令的语法是 s/regexp/replacement/，例如： $ seq 31 36 | sed 's/33/replace/' 31 32 replace 34 35 36 $ # 替换行尾的数字 3 和 5 $ seq 31 36 | sed 's/[35]$/replace/' 31 32 3replace 34 3replace 36 ","date":"2020-10-01","objectID":"/sed/:3:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"自定义分割符 替换命令中的分割符 / 也可以用其他符号代替，例如： $ # 常规书写方式 $ echo \"/bin/sh test.sh\" | sed 's/\\/bin\\/sh/\\/bin\\/bash/' /bin/bash test.sh $ $ # 自定义分割符 $ echo \"/bin/sh test.sh\" | sed 's%/bin/sh%/bin/bash%' /bin/bash test.sh $ echo \"/bin/sh test.sh\" | sed 's!/bin/sh!/bin/bash!' /bin/bash test.sh 上面这个例子需要在正则表达式中多次书写 / 符号，如果是 s/regexp/replacement/ 这样的写法，正则表达式里面好几个 / 需要加转义字符，写出来非常难看。改成 s%regexp%replacement% 这样的写法会简洁很多。 可以使用任意单个符号替代 /，恢复该符号的字面量需要加转义字符。 ","date":"2020-10-01","objectID":"/sed/:3:1","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"行内定位 sed 默认对每行第 1 次匹配进行替换，也可以全部替换或者选择性替换，例如： $ # 替换第 1 次匹配 $ echo \"a dog and a cat\" | sed 's/a/A/' A dog and a cat $ $ # 替换第 3 次匹配 $ echo \"a dog and a cat\" | sed 's/a/A/3' a dog and A cat $ $ # 替换所有匹配 $ echo \"a dog and a cat\" | sed 's/a/A/g' A dog And A cAt ","date":"2020-10-01","objectID":"/sed/:3:2","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"行定位 可以明确指定行数或行区间，例如： $ # 替换第三行 $ seq 6 | sed '3s/$/foo/' 1 2 3foo 4 5 6 $ # 从第三行到第五行 $ seq 6 | sed '3,5s/$/foo/' 1 2 3foo 4foo 5foo 6 $ # 从第三行到最后一行 $ seq 6 | sed '3,$s/^/foo/' 1 2 foo3 foo4 foo5 foo6 上例中，正则表达式 /$/ 匹配行尾，此时替换命令可以在行尾添加文本。同样 /^/ 可以实现行首添加文本。行区间 3,$ 代表从第三行到最后一行。 ","date":"2020-10-01","objectID":"/sed/:3:3","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"删除行 命令 d 用于删除行，例如： $ seq 6 | sed '3d' 1 2 4 5 6 ","date":"2020-10-01","objectID":"/sed/:4:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"修改行 命令 c 用于修改行，例如： $ seq 6 | sed '3c\\change' 1 2 change 4 5 6 $ echo -e \"line 1\\nline 2\\nend\" line 1 line 2 end $ echo -e \"line 1\\nline 2\\nend\" | sed '/line/c\\change' change change end 修改命令 c 与替换命令 s 不同，它相当于删除旧行再插入新行。 ","date":"2020-10-01","objectID":"/sed/:5:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"插入和附加新行 命令 i 在匹配的行前面插入新行。命令 a 在匹配的行后面附加新行。请看下面的例子： $ seq 6 | sed '6i\\insert' 1 2 3 4 5 insert 6 $ seq 6 | sed '6a\\append' 1 2 3 4 5 6 append ","date":"2020-10-01","objectID":"/sed/:6:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"一次执行多条命令 -e 选项可以执行多条命令，例如： $ seq 6 | sed -e '2d' -e '5d' 1 3 4 6 $ seq 6 | sed -e '2d' -e '3i\\insert' -e '5d' 1 insert 3 4 6 ; 分割多条命令，例如： $ seq 6 | sed -e '2d; 5d' 1 3 4 6 ","date":"2020-10-01","objectID":"/sed/:7:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"sed 实践 ","date":"2020-10-01","objectID":"/sed/:8:0","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"修改 apt 源 $ # 源文件 $ cat /etc/apt/sources.list deb http://deb.debian.org/debian buster main deb-src http://deb.debian.org/debian buster main deb http://deb.debian.org/debian-security/ buster/updates main deb-src http://deb.debian.org/debian-security/ buster/updates main deb http://deb.debian.org/debian buster-updates main deb-src http://deb.debian.org/debian buster-updates main $ $ # 修改文件 $ sudo sed -E -i.sed '/^deb/s%(https?|ftp)://[^/]+/%http://mirrors.aliyun.com/%' /etc/apt/sources.list $ $ # 修改后的文件 $ cat /etc/apt/sources.list deb http://mirrors.aliyun.com/debian buster main deb-src http://mirrors.aliyun.com/debian buster main deb http://mirrors.aliyun.com/debian-security/ buster/updates main deb-src http://mirrors.aliyun.com/debian-security/ buster/updates main deb http://mirrors.aliyun.com/debian buster-updates main deb-src http://mirrors.aliyun.com/debian buster-updates main ","date":"2020-10-01","objectID":"/sed/:8:1","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"修改 profile 文件 $ # 写入样例数据 $ sed -i '$a\\export EDITOR=nano' ~/.profile $ sed -i '$a\\export EDITOR=vim' ~/.profile $ grep 'export EDITOR=' ~/.profile export EDITOR=nano export EDITOR=vim $ $ # 删除配置项 $ sed -i '/^export EDITOR\\s*=/d' ~/.profile $ grep 'export EDITOR=' ~/.profile $ $ # 添加配置项 $ sed -i '$a\\export EDITOR=/usr/bin/vim' ~/.profile $ grep 'export EDITOR=' ~/.profile export EDITOR=/usr/bin/vim 上面这个例子，配置文件有多行重复的配置项，可以先删除再添加。 ","date":"2020-10-01","objectID":"/sed/:8:2","tags":["linux基础"],"title":"sed 流编辑器","uri":"/sed/"},{"categories":["爱技术爱折腾"],"content":"shell 基础命令简介","date":"2020-10-01","objectID":"/basic-commands/","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"最基础的命令 echo cd pwd ls cat echo 显示一行文本 cd 切换目录 pwd 查看当前所在目录 ls 查看目录信息，通常用来查看目录下有哪些文件 cat 串联文件并打印，通常用来阅读文本文件 例如： $ echo \"Basic Commands\" Basic Commands $ echo \"查看文件\" 查看文件 $ cat /etc/os-release PRETTY_NAME=\"Debian GNU/Linux 10 (buster)\" NAME=\"Debian GNU/Linux\" VERSION_ID=\"10\" VERSION=\"10 (buster)\" VERSION_CODENAME=buster ID=debian HOME_URL=\"https://www.debian.org/\" SUPPORT_URL=\"https://www.debian.org/support\" BUG_REPORT_URL=\"https://bugs.debian.org/\" $ $ echo \"切换到用户主目录\" 切换到用户主目录 $ cd ~ $ $ echo \"查看当前所在目录\" 查看当前所在目录 $ pwd /home/linux-20 $ $ echo \"查看当前目录信息\" 查看当前目录信息 $ ls 图片 文档 下载 音乐 桌面 backup bin download lib ... $ $ echo \"查看根目录信息\" 查看根目录信息 $ ls / bin dev home mnt run tmp var etc lib root sbin usr ... !!! note $ 是 shell 提示符，表示该行是 shell 命令，不以该符号开头的行是输出信息。上面第一行 $ echo \"Basic Commands\" 中 echo \"Basic Commands\" 是用户输入的命令，第二行 Basic Commands 是输出的信息。 ","date":"2020-10-01","objectID":"/basic-commands/:1:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"简单创建文本文件 echo 还可用于创建文本文件，请看下面的例子： $ echo \"some text\" \u003e example.txt $ cat example.txt some text $ echo \"new text\" \u003e example.txt $ cat example.txt new text $ echo \"append\" \u003e\u003e example.txt $ cat example.txt new text append 若文件已存在，使用 \u003e 总是覆盖文件，使用 \u003e\u003e 可附加一行。 ","date":"2020-10-01","objectID":"/basic-commands/:1:1","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"ls 显示更多信息 ls 最常用的选项有： -a 显示所有文件，包括隐藏文件 -l 使用长列表格式，将显示更多文件信息 $ ls -al ~ total 148 drwxr-xr-x 3 linux-20 linux-20 4096 Feb 16 14:11 . drwxr-xr-x 9 root root 4096 Feb 18 12:57 .. -rw-r--r-- 1 linux-20 linux-20 70 Jan 19 17:21 .bash_aliases -rw------- 1 linux-20 linux-20 1420 Feb 16 20:52 .bash_history -rw-r--r-- 1 linux-20 linux-20 220 Jan 19 17:18 .bash_logout -rw-r--r-- 1 linux-20 linux-20 3590 Jan 19 17:24 .bashrc -rw-r--r-- 1 linux-20 linux-20 971 Jan 21 16:05 .profile -rw------- 1 linux-20 linux-20 7537 Feb 16 13:18 .viminfo -rw------- 1 linux-20 linux-20 82 Feb 16 14:11 .zsh_history -rw-r--r-- 1 linux-20 linux-20 1295 Feb 16 14:06 .zshrc -rw------- 1 linux-20 linux-20 1420 Feb 12 21:39 download -rw------- 1 linux-20 linux-20 1420 Feb 16 20:56 project ... ","date":"2020-10-01","objectID":"/basic-commands/:1:2","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"目录和文件操作 mkdir 创建目录 touch 修改文件时间戳，也可用于创建空文件 cp 复制文件 mv 移动文件 rm 删除文件 $ mkdir linux-20 $ cd linux-20 $ $ touch foo $ cp foo foo-2 $ ls foo foo-2 $ mv foo bar $ ls bar foo-2 $ rm bar foo-2 ","date":"2020-10-01","objectID":"/basic-commands/:2:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"ln 创建文件链接 ln 用于创建文件链接，默认创建硬链接，ln -s 可以创建软链接。请看下面的例子： $ # 创建 foo 文件，并为其创建硬链接和软链接 $ touch foo $ ln foo foo-ln $ ln -s foo bar $ ls -l lrwxrwxrwx 1 linux-20 linux-20 3 Feb 18 16:49 bar -\u003e foo -rw-r--r-- 2 linux-20 linux-20 0 Feb 18 16:49 foo -rw-r--r-- 2 linux-20 linux-20 0 Feb 18 16:49 foo-ln $ echo \"text for foo\" \u003e foo $ echo \"append for bar\" \u003e\u003e bar $ cat foo-ln text for foo append for bar $ cat bar text for foo append for bar ls -l 可以明显看到软链接的关系，而硬链接不能直观看出来。不管是硬链接还是软链接，都可以对其读写，使得一个文件有多个访问路径。 ","date":"2020-10-01","objectID":"/basic-commands/:2:1","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"查看文件内容 前面已经介绍了使用 cat 查看文件内容，cat 一次性将文件内容打印出来，如果文件有数页或更多时则不太好用。这里还有几个命令可以查看文件： more 通过翻页的形式查看文件 head 查看文件开头几行 tail 查看文件末尾几行 head 和 tail 默认输出 10 行，使用 -n 参数可指定行数，例如 head -n 1 /etc/os-release 只输出第一行。 ","date":"2020-10-01","objectID":"/basic-commands/:3:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"进程管理 top ps kill top 可查看所有进程和系统资源信息，进入后可翻页，按 q 退出。 ps 可以查看当前进程 (当前 shell 进程和此时运行的 ps 进程)，ps -ef 可以查看所有进程并输出更多信息。 pgrep 可以根据名称搜索进程，pgrep -l firefox 搜索包含关键字 firefox 的进程。-l 仅显示进程名，需要完整显示进程可使用 -a (显示进程完整路径和参数)。默认只匹配进程名 (-l 显示的字串)，-f 可完整匹配 (-a 显示的字串)。请看下面的例子： $ pgrep -l firefox 26658 firefox-esr $ $ pgrep -lf firefox 26658 firefox-esr 26705 Web Content 26747 Web Content 26908 WebExtensions $ $ pgrep -af firefox 26658 /usr/lib/firefox-esr/firefox-esr 26705 /usr/lib/firefox-esr/firefox-esr -contentproc -childID 1 -isForBrowser -prefsLen 1 -prefMapSize 188430 -parentBuildID 20200206211857 -greomni /usr/lib/firefox-esr/omni.ja -appomni /usr/lib/firefox-esr/browser/omni.ja -appdir /usr/lib/firefox-esr/browser 26658 true tab ... kill \u003cpid\u003e 可终止进程，kill -9 \u003cpid\u003e 可强制杀死进程，pid 可通过 top、ps、pgrep 看到。 ","date":"2020-10-01","objectID":"/basic-commands/:4:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"查看系统资源 ","date":"2020-10-01","objectID":"/basic-commands/:5:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"free free 可查看物理内存和 swap 使用情况，默认输出的数据以 KB 为单位，-h 选项自动进行单位换算使输出结果便于阅读，-w 支持宽列表输出，输出信息如下： $ free -hw total used free shared buffers cache available Mem: 7.7Gi 4.3Gi 1.2Gi 544Mi 629Mi 1.5Gi 2.6Gi Swap: 14Gi 853Mi 14Gi 下面是输出信息中的部分字段的解释： total 总内存容量。 free 空闲的内存。 cache 用于读取磁盘的内存缓存 (page cache and slabs)。这些内存可自动回收以供新的程序运行。 available 系统评估的可供运行新程序的内存容量 (MemAvailable in /proc/meminfo) ","date":"2020-10-01","objectID":"/basic-commands/:5:1","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"df df 可查看磁盘使用情况，-h 选项自动进行单位换算使输出结果便于阅读，-T 选项输出文件系统类型，输出信息如下： $ df -hT Filesystem Type Size Used Avail Use% Mounted on /dev/mapper/VG01-root ext4 28G 11G 16G 41% / /dev/sda1 ext2 938M 109M 782M 13% /boot /dev/sda2 vfat 953M 32M 921M 4% /boot/efi /dev/mapper/VG01-var ext4 55G 10G 43G 20% /var /dev/mapper/VG01-home ext4 314G 217G 82G 73% /home tmpfs tmpfs 3.9G 174M 3.7G 5% /dev/shm … ","date":"2020-10-01","objectID":"/basic-commands/:5:2","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"网络工具 ","date":"2020-10-01","objectID":"/basic-commands/:6:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"ip address ip address 可查看网络接口和「ip地址」，输出信息如下： $ ip address 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: enp2s0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc fq state DOWN group default qlen 1000 link/ether 68:f7:28:44:ff:25 brd ff:ff:ff:ff:ff:ff 3: wlp3s0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP group default qlen 1000 link/ether d0:7e:35:6a:df:ec brd ff:ff:ff:ff:ff:ff inet 192.168.3.4/24 brd 192.168.3.255 scope global dynamic noprefixroute wlp3s0 valid_lft 598755sec preferred_lft 598755sec $ ","date":"2020-10-01","objectID":"/basic-commands/:6:1","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"curl 下载文件 下载文件可使用 curl 工具，命令格式如下： curl https://github.com/itboon/storage/raw/master/vim/vimrc -L -o vimrc.tmp curl 默认只将数据打印出来，-o 用于保存为文件。-L 用于支持网页重定向。 ","date":"2020-10-01","objectID":"/basic-commands/:6:2","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"tar 打包和压缩 tar 是一款打包工具，打包后的文件称为「tar包」。下面是最常用的几项操作： # 将 foo 目录打包为 foo.tar tar -c -f foo.tar foo # 打包并使用 gzip 压缩 tar -c -g -f foo.tar.gz foo # 列出「tar包」里面的文件 tar -t -f foo.tar # 从「tar包」释放文件 tar -x -f foo.tar # 释放文件到指定文件夹 tar -x -f foo.tar -C /tmp 选项解释： -c 创建「tar包」。 -t 列出「tar包」里面的文件。 -x 从「tar包」释放文件。 -f 指定「tar包」文件名。 tar 还支持简洁的写法，例如： tar cf foo.tar foo tar tf foo.tar tar xf foo.tar ","date":"2020-10-01","objectID":"/basic-commands/:7:0","tags":["linux基础"],"title":"shell 基础命令简介","uri":"/basic-commands/"},{"categories":["爱技术爱折腾"],"content":"shell 条件语句","date":"2020-10-01","objectID":"/shell-conditional/","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"if if 语句的语法如下： if test-commands; then commands... elif test-commands; then commands... else commands... fi # elif 是可选的并且可以有多条 # else 是可选的 if 语句在测试命令 test-commands 返回值为零时 (即条件为真时) 执行 then 后面的命令。当所有条件都不满足时，则执行 else 子句。其中 elif 是可选的并且可以有多条，用来提供更多条件测试。else 也是可选的。请看下面的例子： if [ -f \"$HOME/.bashrc\" ]; then . \"$HOME/.bashrc\" fi 这里使用 if 语句确保文件存在再执行。[ -f \"$HOME/.bashrc\" ]; 这个条件表达式用于判断文件是否存在。. \"$HOME/.bashrc\" 等同于 source \"$HOME/.bashrc\"，用于在当前 shell 执行文件。 借助分号可以将上面的命令写到一行： if [ -f \"$HOME/.bashrc\" ]; then . \"$HOME/.bashrc\"; fi ","date":"2020-10-01","objectID":"/shell-conditional/:1:0","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"常用条件判断 -f file 文件存在且为普通文件。 -d file 文件存在且为目录文件。 -e file 文件存在。 s1 == s2 字符串相等。 s1 != s2 字符串不等。 n1 OP n2 数字比较，OP 可以是这些：-eq -ne -lt -le -gt -ge，分别判断 n1 是否等于、不等于、小于、小于等于、大于、大于等于 n2。 -z string 字符串为空。 -n string 字符串不为空。 ","date":"2020-10-01","objectID":"/shell-conditional/:2:0","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"条件表达式 常规的条件表达式有两种写法，test expression 和 [ expression ] (方括号里面前后各有一个空格，不能少)。请看下面的例子： $ [ -d /etc ] \u0026\u0026 echo true true $ [ -d /foo ] \u0026\u0026 echo true $ [ 5 -gt 3 ] \u0026\u0026 echo true true $ echo \"$USER $(id -u)\" linux-20 1002 $ [ $(id -u) -ge 1000 ] \u0026\u0026 echo true true $ [ $USER != root ] \u0026\u0026 echo true true 这里在条件表达式后面加上 \u0026\u0026 echo true，若条件为真则执行 echo，它相当于简短的 if 语句 if [ -d /etc ]; then echo true; fi。 条件表达式可以进行与或非处理： [ ! expression ] 否定判断。 [ expression1 -a expression2 ] 两个表达式都为真。 [ expression1 -o expression2 ] 两个表达式中任意一个为真。 ","date":"2020-10-01","objectID":"/shell-conditional/:3:0","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"双方括号 [[ expression ]] bash 可以用双放括号代替方括号，它提供了增强特性，支持正则表达式，例如： $ [[ $USER =~ ^linux ]] \u0026\u0026 echo hello $USER hello linux-20 [[ $USER =~ ^linux ]] 如果用户名以 linux 开头则为真。关于正则表达式将在 grep 章节介绍，这里只简单了解一下。 ","date":"2020-10-01","objectID":"/shell-conditional/:3:1","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"双括号 (( expression )) 双括号表达式即算术表达式，它有以下特点： 支持算术运算符。 支持多个表达式，表达式之间用逗号 , 分开。 双括号里面调用变量可省略 $ 符号。 双括号里前后的空格可以省略。 调用算术表达式的结果使用 $(( expression )) 。 $ echo $((3 + 7)), $((3 * 7)) 10, 21 $ i=1; ((i=i+5, i=i*2)); echo $i 12 $ i=1; ((i++, i++)); echo $i 3 $ i=100; ((i==100)) \u0026\u0026 echo true true $ i=100; ((i\u003e=5)) \u0026\u0026 echo true true $ (($(id -u) != 0)) \u0026\u0026 echo \"I am not root\" I am not root ","date":"2020-10-01","objectID":"/shell-conditional/:3:2","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"case case 是 if 语句的变种，一般用于对变量进行分类比对，例如： echo ${LANG:0:2} case ${LANG:0:2} in zh) lang=Chinese;; en) lang=English;; *) lang=unkown;; esac echo \"You are using $lang\" 上面执行后将得到如下输出： $ echo ${LANG:0:2} en $ case ${LANG:0:2} in \u003e zh) lang=Chinese;; \u003e en) lang=English;; \u003e *) lang=unkown;; \u003e esac $ echo \"You are using $lang\" You are using English case 经常用于 shell 脚本的交互设计，根据用户的输入控制脚本的流程，例如： echo -n \"Continue [Yes/No]\"; read answer case $answer in y | yes) echo \"doing something\";; n | no) echo \"doing nothing\";; * ) echo \"unknown answer\";; esac ","date":"2020-10-01","objectID":"/shell-conditional/:4:0","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"select select 可用来制作菜单，它经常与 case 配合使用，例如： echo \"Choose a shell: \" select shell in \"ash\" \"bash\" \"zsh\" \"Exit\" do case $shell in ash) echo \"ash is Almquist shell\";; bash) echo \"bash is Bourne-Again shell\";; zsh) echo \"zsh is Z shell\";; Exit) break;; *) echo unkown;; esac done ","date":"2020-10-01","objectID":"/shell-conditional/:5:0","tags":["linux基础"],"title":"shell 条件语句","uri":"/shell-conditional/"},{"categories":["爱技术爱折腾"],"content":"shell 语法","date":"2020-10-01","objectID":"/shell-syntax/","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"注释 一行中 # 及其后面的字符会被 shell 忽略，这被称为注释。 $ # echo foo $ echo foo # comments foo ","date":"2020-10-01","objectID":"/shell-syntax/:1:0","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"引号 引号将字符包裹起来恢复其字面量，单引号里面所有特殊字符均恢复字面量，而双引号则保留 $ ` \\ 这 3 个符号的特殊含义 (` 是反引号)。请看下面的例子： $ echo foo # bar foo $ echo \"foo # bar\" foo # bar $ echo 'foo # bar' foo # bar $ $ echo \"$USER\" linux-20 $ echo '$USER' $USER echo foo # bar 其中 # bar 为注释，用引号包裹起来则恢复 # 字面量。双引号中仍然可以使用变量，而单引号不可以。 ","date":"2020-10-01","objectID":"/shell-syntax/:2:0","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"转义字符 转义字符可恢复特殊字符的字面量，例如： $ echo \"$USER\" linux-20 $ echo \"\\$USER\" $USER $ echo \"\\\"foo\\\"\" \"foo\" ","date":"2020-10-01","objectID":"/shell-syntax/:3:0","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"换行符 \\n echo 可以一次输出多行文本，请看下面的例子： $ echo \"foo\\nbar\" foo\\nbar $ echo -e \"foo\\nbar\" foo bar echo -e 开启转义序列，可识别换行符 \\n、制表符 \\t 等符号。 ","date":"2020-10-01","objectID":"/shell-syntax/:3:1","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"命令序列 可以在一行书写多条独立的命令，它们会按顺序执行，这需要下列符号支持： ; 多条命令写在一行用 ; 隔开，将按顺序执行。 \u0026\u0026 若前面的命令返回值为非零 (执行成功)，则继续执行后面的命令。 || 若前面的命令返回值为零 (执行失败)，则继续执行后面的命令。 \u0026 可将多条命令隔开，类似;，不同点在于此符号放在命令末尾将调用子进程异步执行该命令，也称为后台任务。 例如： $ echo foo; echo bar foo bar $ echo foo \u0026\u0026 echo bar foo bar $ echo foo || echo bar foo $ $ echofoo \u0026\u0026 echo bar -bash: echofoo：未找到命令 $ echofoo || echo bar -bash: echofoo：未找到命令 bar ","date":"2020-10-01","objectID":"/shell-syntax/:4:0","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"后台任务 \u0026 可用于执行后台任务，请看下面的例子： $ sleep 3; echo foo foo $ sleep 3\u0026 echo foo [1] 26056 foo $ jobs [1]+ 已完成 sleep 3 $ $ sleep 100\u0026 sleep 500\u0026 [1] 26108 [2] 26109 $ fg 1 sleep 100 ^C $ jobs [2]+ 运行中 sleep 500 \u0026 $ kill %2 $ jobs [2]+ 已终止 sleep 500 sleep 3; echo foo 会延迟 3 秒再执行 echo；将 ; 换成 \u0026 则 sleep 在子进程执行，不会阻塞后面的命令。 jobs 可列出活动的后台任务，fg 可将后台任务切换到前台 (然后按 Ctrl + C 可终止)，kill 可直接终止后台任务。 ","date":"2020-10-01","objectID":"/shell-syntax/:4:1","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"命令返回值 一条命令执行完成后会得到一个返回值 (exit status)，这个值保存在 $?，请看下面的例子： $ echo foo; echo $? foo 0 $ echofoo; echo $? -bash: echofoo：未找到命令 127 $ echofoo \u0026\u0026 echo $? -bash: echofoo：未找到命令 返回值为零表示执行成功，非零表示执行失败。\u0026\u0026 需要前一条命令的返回值为零才执行后面的命令。 ","date":"2020-10-01","objectID":"/shell-syntax/:5:0","tags":["linux基础"],"title":"shell 语法","uri":"/shell-syntax/"},{"categories":["爱技术爱折腾"],"content":"shell 字符扩展","date":"2020-10-01","objectID":"/shell-expansions/","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"「shell 字符扩展」支持用简洁的输入代替冗余的命令，比如 cd ~、mkdir foo/bar/{a,b,c}，这些技巧是非常有帮助的。 bash 支持以下字符扩展： 大括号扩展 波浪号扩展 变量扩展 命令置换 算术扩展 文件名扩展 ","date":"2020-10-01","objectID":"/shell-expansions/:0:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"大括号扩展 大括号扩展可以帮助批量生成字符串，例如： $ echo test-{1,2,3,foo} test-1 test-2 test-3 test-foo $ $ mkdir -p ~/test/foo-a ~/test/foo-b $ mkdir -p ~/test/brace-{a,b,c} $ ls ~/test brace-a brace-b brace-c foo-a foo-b 批量操作文件和目录时，如果它们有相同的前缀或后缀，使用大括号扩展会非常方便。 ","date":"2020-10-01","objectID":"/shell-expansions/:1:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"波浪号扩展 波浪号扩展使用简单的符号取代 home 目录和工作目录的值，常用的有下面这些： ~ 当前用户的 home 目录，等于 $HOME 的值。 ~username 特定用户的 home 目录。 ~+ 当前工作目录，等于 $PWD 的值。 ~- 上一个工作目录，等于 $OLDPWD 的值。 ~ 作为扩展使用时必须放在单词开头，放在单词中间将被识别为普通符号。它后面的字符仍然是有特殊含义的，直到斜杠 / 为止。因此，~foo 将被识别为 foo 用户的 home 目录，如果用户不存在则保持其字面值不变。请看下面的例子： $ echo ~ /home/linux-20 $ echo ~/foo /home/linux-20/foo $ echo ~foo ~foo $ echo ~root /root ","date":"2020-10-01","objectID":"/shell-expansions/:2:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"变量扩展 可以截取变量的一部分字符 ${var:-word} 当变量为空时，替换为 :- 后面的字符；当变量不为空时替换为变量的值。 ${var:=word} 当变量为空时，使用 := 后面的字符为变量赋值；然后替换为变量的值。 ${var:offset} ${var:offset:length} 裁剪变量的值。 调用一个空的变量会导致出错，可以使用 ${var:-word} 或 ${var:=word} 提供备用值，两者区别是前者不对变量赋值而后者赋值。 ${var:offset:length} 可以对变量的值进行裁剪，请看下面的例子： $ foo=12345abcfoo $ echo $foo 12345abcfoo $ echo ${foo:2} 345abcfoo $ echo ${foo: -3} foo $ echo ${foo:2:6} 345abc $ echo ${foo:2:3} 345 $ echo ${foo: -6:3} abc $ echo ${foo: -6:-2} abcf $ echo ${foo::5} 12345 ","date":"2020-10-01","objectID":"/shell-expansions/:3:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"命令置换 命令的输出可作为命令的一部分，这叫命令置换，请看下面的例子： $ ls -l $(which sh) lrwxrwxrwx 1 root root 4 Jan 18 2019 /bin/sh -\u003e dash $ ls -l `which sh` lrwxrwxrwx 1 root root 4 Jan 18 2019 /bin/sh -\u003e dash ls -l $(which sh) 这里将先执行 which sh，然后将其输出替换到命令中，即 ls -l /bin/sh。 $(command) 和 `command` (反引号包裹) 这两种用法都可以，前者便于阅读。 !!! note 反引号 ` 在键盘上数字 1 前面，阅读时不便于识别，因此不推荐使用。 ","date":"2020-10-01","objectID":"/shell-expansions/:4:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"算术扩展 算术扩展 $(( expression )) 可以获取算术表达式得到的值，请看下面的例子： $ echo $(( 3+7 )) 10 $ echo $(( 3*7 )) 21 $ i=5; echo $(( i+3 )) 8 ","date":"2020-10-01","objectID":"/shell-expansions/:5:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"文件名扩展 文件名扩展支持「shell 模式匹配」 ","date":"2020-10-01","objectID":"/shell-expansions/:6:0","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"shell 模式匹配 下列字符在模式匹配中具有特殊含义： * 匹配任意字符，包括空字符。 ? 匹配一个任意字符。 […] 匹配一个包含在列表中的字符。支持区间写法，例如 [abcde] 可以写成 [a-e]，5678 可以写成 [5-8]。 请看下面的例子： $ touch foo-{a,ab,1} $ $ ls foo-* foo-1 foo-a foo-ab $ ls foo-? foo-1 foo-a $ ls foo-[a-z] foo-a $ ls foo-[a-z]* foo-a foo-ab $ $ rm foo-* $ ls foo-* ls: cannot access 'foo-*': No such file or directory $ 模式匹配在创建文件时不被支持，因为创建包含任意字符的文件是不合理的；其他文件操作均支持模式匹配。 ","date":"2020-10-01","objectID":"/shell-expansions/:6:1","tags":["linux基础"],"title":"shell 字符扩展","uri":"/shell-expansions/"},{"categories":["爱技术爱折腾"],"content":"systemd 和 systemctl","date":"2020-10-01","objectID":"/systemd/","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"systemd 是许多「Linux 发行版」默认的 init 程序。init 是操作系统的「一号进程」，内核加载完成后首先运行该进程，接着由它完成后面的系统启动。 除了作为初始化进程外，systemd 还提供其他的功能。包括电源管理、日志记录、系统配置、网络配置、网络时间同步和域名解析等。 ","date":"2020-10-01","objectID":"/systemd/:0:0","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"命令行工具 systemctl 是 systemd 最重要的命令行工具，用于管理操作系统的基础运作。 此外还有下列这些常用的工具： journalctl 查看日志。 systemd-analyze 分析系统启动过程。 resolvectl 域名解析，管理 systemd 域名服务 (systemd-resolved)。 hostnamectl 管理主机名。 localectl 管理区域和语言。 timedatectl 管理时钟。 loginctl 管理用户登录。 有些工具需要在相应的后端服务运行的情况下才可以使用，比如 journalctl 对应的后端服务是 systemd-journald.service，使用 man 可以查询。 ","date":"2020-10-01","objectID":"/systemd/:1:0","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"unit systemd 管理的单元叫 “unit”，unit 可以是服务 (.service)、挂载点 (.mount), 设备 (.device)、sockets (.socket) 等，例如 systemd-networkd.service、boot.mount。 输入命令时 .service 后缀可省略。 ","date":"2020-10-01","objectID":"/systemd/:2:0","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"常用命令汇总 ","date":"2020-10-01","objectID":"/systemd/:3:0","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"systemctl 下面以管理 systemd-timesyncd.service 为例，列出 systemctl 常用命令。 控制类的操作需要 root 权限，例如 start/stop/enable/mask 等 查看状态 $ systemctl status systemd-timesyncd 启动 $ systemctl start systemd-timesyncd 停止 $ systemctl stop systemd-timesyncd 重启 $ systemctl restart systemd-timesyncd 重载配置 $ systemctl reload systemd-timesyncd 设置开机启动 $ systemctl enable systemd-timesyncd 禁用开机启动 $ systemctl disable systemd-timesyncd 检查运行状态 $ systemctl is-active systemd-timesyncd 检查是否开机启动 $ systemctl is-enabled systemd-timesyncd 屏蔽 (服务无法被启动直到 unmask 解除屏蔽) $ systemctl mask systemd-timesyncd 解除屏蔽 $ systemctl unmask systemd-timesyncd systemctl 还可以管理电源： 重启 $ systemctl reboot 关机 $ systemctl shutdown 挂起 (系统状态保存到内存，不断电) $ systemctl suspend 休眠 (系统状态保存到硬盘，然后断电) $ systemctl hibernate 通过 polkit 可实现本地登录的普通用户使用 systemctl 进行电源管理。安装 plokit： $ sudo apt install policykit-1 ","date":"2020-10-01","objectID":"/systemd/:3:1","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"systemd-analyze systemd-analyze 用于分析系统启动过程，常用命令如下： 分析系统启动过程 $ systemd-analyze 分析 units 启动时花费的时间 $ systemd-analyze blame ","date":"2020-10-01","objectID":"/systemd/:3:2","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"journalctl journalctl 用于查看日志，常用命令如下： 查看日志 $ journalctl 查看日志，时间晚的排在前面 $ journalctl -r 查看某个单元的日志 $ journalctl -u systemd-timesyncd !!! note Debian 需要将用户加入 systemd-journal 组才可执行 journalctl，或者调用 root 权限。 ","date":"2020-10-01","objectID":"/systemd/:3:3","tags":["linux基础"],"title":"systemd 和 systemctl","uri":"/systemd/"},{"categories":["爱技术爱折腾"],"content":"单小喏版Clash","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":" 文章的部分内容被密码保护： --- DON'T MODIFY THIS LINE --- ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:0:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"下载地址 Win平台下载地址：点击下载 Mac平台下载地址：点击下载 Mac M1平台下载地址：点击下载 安卓手机下载地址：点击下载 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:1:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"如何使用 打开单小喏版Clash后找到系统代理选项点击开启 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:2:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"版本更新 打开单小喏版Clash后找到配置文件目录选项点击打开文件夹 重要的事情说三遍，更新版本请删除.config文件夹。 重要的事情说三遍，更新版本请删除.config文件夹。 重要的事情说三遍，更新版本请删除.config文件夹。 然后退出程序删除用户目录下的.config文件夹在重新打开程序 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:3:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"常见问题 出现如下情况–点击尝试修复直到修复成功(由于网络原因下载配置节点信息导致程序加载不成功)。 直到修复成功加载到如下界面 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:4:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"订阅地址(此版本软件无需设置–程序已经内置自动更新节点) ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:5:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"稳定版 https://cdn.onlysing.com/clash/clash-stables.yaml ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:5:1","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"测试版 https://cdn.onlysing.com/clash/clash-dev.yaml ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:5:2","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"免费版 https://cdn.onlysing.com/clash/clash-free.yaml ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:5:3","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"使用订阅地址 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:5:4","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"脚本(此版本软件无需设置–程序已经内置自动判断网速) ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:6:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"速度优化 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:7:0","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"win版本测速(需要告知我最后优选的IP地址) 点击下载 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:7:1","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"手机端测速(自动上报优选IP地址) 下载Termux 点击下载 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:7:2","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":["爱技术爱折腾"],"content":"优选线路选择 移动线路 curl https://cdn.onlysing.com/speed/linux/cf_yd.sh -o cf_yd.sh \u0026\u0026 chmod +x cf_yd.sh \u0026\u0026 ./cf_yd.sh 电信线路 curl https://cdn.onlysing.com/speed/linux/cf_dx.sh -o cf_dx.sh \u0026\u0026 chmod +x cf_dx.sh \u0026\u0026 ./cf_dx.sh 联通线路 curl https://cdn.onlysing.com/speed/linux/cf_lt.sh -o cf_lt.sh \u0026\u0026 chmod +x cf_lt.sh \u0026\u0026 ./cf_lt.sh 根据运营商选择线路复制上方链接粘贴到termux并回车 ","date":"2020-10-01","objectID":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/:7:3","tags":["代理","小猫咪"],"title":"单小喏版Clash","uri":"/%E5%8D%95%E5%B0%8F%E5%96%8F%E7%89%88clash/"},{"categories":null,"content":" 陌生人您好🤝，欢迎在我的博客留下👣，不知道您是从何处来到的这里，但这并不重要。因为相遇即是缘分，世界上的人总会通过各种方式产生千丝万缕的联系，所以，即使我们素为谋面，您来到这里，我们就是朋友💖 ","date":"2020-10-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"关于我 👨‍💻 爱折腾的程序猿，立志成为架构师。 💻 技术宅,热爱关于计算机的一切。 🤔 热衷于了解世界的运转机制 ❤ 爱好音乐和动漫。 ","date":"2020-10-01","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"为什么要写博客 苏轼《题西林壁》有名句:「不识庐山真面目，只缘身在此山中。」 写博客是一种找回文字的宁静,但又困于浮躁和慵懒,于是转向了这一折中——更随意的播客。 写博客可以记录自己的一种心情和状态;每一种传播方式不同,带来的感受也不同。 博客的实用之处： 一、通过写博客可以让你在快节奏的都市生活中慢下来，能让你在这个「抖心」的时代静心下来。 二、孔子有言「学而不思则罔」（《论语·为政》），多闻多见却不认真思考是茫然无获的。孔子又言「下学而上达」（《论语·宪问》），所谓「下学」，即多学而识，即学习新知识；所谓「上达」，即一以贯之，即思考、反省、总结。可见，思基于学但又高于学，而写博客就是「思」的过程，写博客就是「上达」的过程。这里还需特别注意，不能将「学」简单理解为看书，生活、技术、电影、音乐等等方面的经历也是「学」，故也需要「思」。因此，如果你是个技术人员，你不仅应该在自己的博客上记录自己的技术折腾，也应该去记录自己的生活经历。当然，和别人交谈也是一种反思的过程，但用文字记录下来会更易读、更有利于传播。 三、通过写博客，你的想法能够在互联网世界中传播，成就更大的价值。思想的价值在于传播，如果你不与这个世界建立联系，不将自己的发现分享出去，那么你的发现其实是毫无价值的。另对个人来说，只有将你的作品分享出去、传播出去，你才会是一个成功的人。 ","date":"2020-10-01","objectID":"/about/:1:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"为什么要选择博客 一、博客是一本现代的电子笔记本。 二、博客能够完美且简单地解决笔记的组织和分类问题。 三、相比微信朋友圈，博客不仅更为纯净，还更为强大、灵活、自由。此外，朋友圈的传播范围只限于你的好友，但博客却能够传播到互联网的每一角落。 ","date":"2020-10-01","objectID":"/about/:1:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"博客访问地址 托管在GitHub Pages https://www.danxiaonuo.me 托管在Okteto https://blog.danxiaonuo.workers.dev ","date":"2020-10-01","objectID":"/about/:2:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有的原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 版权说明 任何个人及媒体在转载本站原创内容（包含文字、自制图像、摄影作品）时请遵守以下版权要求： 注明转载 注明来源为本站首页网址 www.danxiaonuo.me，或所转内容在本站的完整网址。 本站图片部分来自互联网。 此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注中文说明）过的图片， 联系方式见本站首页。 ","date":"2020-10-01","objectID":"/about/:3:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"参考文献 参考来源: (https://io-oi.me/tech/on-three-questions-about-blogging) ","date":"2020-10-01","objectID":"/about/:4:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["爱技术爱折腾"],"content":"管理用户和组","date":"2020-10-01","objectID":"/user-and-group/","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"底层工具和前端工具 管理用户和组可以使用底层工具 useradd、groupadd、usermod，也可以使用 adduser 这种对用户友好的前端工具。前端工具适合交互式操作，上手简单；底层工具适合在脚本中使用，学习成本稍微高一点。 ","date":"2020-10-01","objectID":"/user-and-group/:1:0","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"常用命令汇总 这里把管理用户和组的相关命令列出来，命令中 jack 是用户名，group01 是组名。个别命令会进入对话模式，请勿全部复制粘贴。 # 创建用户 sudo adduser jack # 创建组 sudo addgroup group01 # root 强制修改用户密码 sudo passwd jack # 修改自己的密码 passwd # 将用户加入组 sudo adduser jack group01 # 删除组 sudo delgroup group01 # 删除用户 sudo deluser jack --remove-home ","date":"2020-10-01","objectID":"/user-and-group/:2:0","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"adduser 下面演示如何创建一个用户、将用户加入组，最后删除用户： $ sudo adduser jack Adding user `jack' ... Adding new group `jack' (1004) ... Adding new user `jack' (1003) with group `jack' ... Creating home directory `/home/jack' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for jack Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] $ id jack uid=1003(jack) gid=1004(jack) groups=1004(jack) $ sudo adduser jack sudo Adding user `jack' to group `sudo' ... Adding user jack to group sudo Done. $ id jack uid=1003(jack) gid=1004(jack) groups=1004(jack),27(sudo) $ sudo deluser jack --remove-home Looking for files to backup/remove ... Removing files ... Removing user `jack' ... Warning: group `jack' has no more members. Done. adduser jack 执行之后进入对话模式，输入密码两次，后面可以一路回车。默认会创建「home 目录」，并创建与用户同名的组。更多默认选项通过 /etc/adduser.conf 配置。 ","date":"2020-10-01","objectID":"/user-and-group/:3:0","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"useradd -b, --base-dir 指定新用户「home 目录」的基目录 -d, --home-dir 指定新用户的「home 目录」 -m, --create-home 创建「home 目录」 -M, --no-create-home 不创建「home 目录」 -p, --password PASSWORD 指定新用户的密码，可以是明文也可以是密文 -s, --shell SHELL 新用户的「登录 shell」 -u, --uid UID 指定新用户的 ID -g, --gid GROUP 指定新用户主组的名称或 ID 使用 useradd 创建一个常规用户： # 创建 jack 用户，设置密码为 PASSWORD，并创建「home 目录」 useradd jack -p PASSWORD -m ","date":"2020-10-01","objectID":"/user-and-group/:4:0","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"创建非登录用户 创建非登录用户可指定 -s /usr/sbin/nologin，即禁用「登录 shell」，命令如下： useradd jack -d /var/lib/jack -m -s /usr/sbin/nologin ","date":"2020-10-01","objectID":"/user-and-group/:4:1","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"修改密码 passwd 以对话模式修改密码，一次修改一个用户；chpasswd 可以批量修改密码，它从 stdin 读取用户名和密码。 chpasswd 使用方法如下： $ echo \"jack:NewPassword\" | sudo chpasswd $ cat passwd.list jack:pw-jack user01:pw-01 user02:pw-02 $ cat passwd.list | sudo chpasswd $ ","date":"2020-10-01","objectID":"/user-and-group/:5:0","tags":["linux基础"],"title":"管理用户和组","uri":"/user-and-group/"},{"categories":["爱技术爱折腾"],"content":"环境变量","date":"2020-10-01","objectID":"/shell-env/","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"我们先通过实际操作来看看一些系统环境变量： $ echo $SHELL /bin/bash $ $ echo $USER linux-20 $ $ echo $HOME /home/linux-20 $ $ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/local/go/bin:/usr/local/nodejs/bin:/home/linux-20/go/bin:/home/linux-20/.local/bin $ $ printenv LANG en_US.UTF-8 echo $VAR 可查看所有环境变量，printenv VAR 只可查看全局环境变量。 调用变量使用 $ 加变量名，比如 $USER、$PATH，更规范的书写方式是 ${USER}、${PATH}。我们通过一个例子看看两者的区别： $ echo $USER linux-20 $ $ echo $USER_book $ echo ${USER}_book linux-20_book $USER_book 这个变量是不存在的，我们需要将 _book 作为普通字串放到 $USER 后面组成新的字串，此时必须书写为 ${USER}_book。 可以看到，加大括号的书写方式比较清晰，而且能够明确界定变量字串和普通字串。 ","date":"2020-10-01","objectID":"/shell-env/:0:0","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"全局环境变量/局部环境变量 环境变量有两种，「全局环境变量」和「局部环境变量」。全局变量对当前 shell 及子 shell 有效，局部变量仅对当前 shell 有效。 foo=bar 即定义了局部环境变量 foo，它的值是 bar。定义全局环境变量，foo=bar; export foo (可以将多行命令写在一行，用分号隔开) 或者 export foo=bar。请看下面的例子： $ # 定义局部环境变量 $ foo=bar $ echo $foo bar $ # 启动一个 bash 子进程，局部环境变量不会传递 $ bash $ echo $foo $ # 定义全局环境变量 $ export foo=bar $ echo $foo bar $ # 再启动一个 bash 子进程，全局环境变量继续可用 $ bash $ echo $foo bar $ # 退出 bash 子进程，回到初始 bash $ exit exit $ exit exit env 或者 printenv 可输出所有全局环境变量，set 可输出所有环境变量 (输出结果会很长)。unset VAR 可删除环境变量。 ","date":"2020-10-01","objectID":"/shell-env/:1:0","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"profile 退出 bash 进程后，该进程运行时定义的环境变量也就不存在了。定义永久的环境变量则需要保存到相应的配置文件，此配置文件也称 profile。 profile 有系统级的和用户级的，系统级的 profile 是 /etc/profile，用户级的 profile 通常是 ~/.profile (~ 表示当前用户的 home 目录)。 当启动交互式的登录 bash，首先加载系统 profile，然后加载用户 profile。用户 profile 是 ~/.bash_profile ~/.bash_login ~/.profile 这三个文件中的一个，按顺序读取，首先读取成功的有效。因此这三个文件有一个就可以，建议使用 ~/.profile，除了 bash 它还被其他多种 shell 程序支持。 用户 profile 中有这样的脚本：if [ -f ~/.bashrc ]; then . ~/.bashrc; fi，意思是如果 ~/.bashrc 文件存在，则执行它。这段脚本默认是有的，可别轻易删除了。 ","date":"2020-10-01","objectID":"/shell-env/:2:0","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"/etc/profile.d /etc/profile 有如下配置： if [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset i fi 这一段的作用是 /etc/profile.d 这个目录下所有以 .sh 结尾的文件都将作为系统 profile 加载。因此用户可以创建一个 /etc/profile.d/local.sh 文件，作为系统级的 profile 文件，这样管理会更加清晰。 ","date":"2020-10-01","objectID":"/shell-env/:2:1","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"$PATH $PATH 是非常重要的一个变量，当我们敲一个命令，系统会在 $PATH 定义的路径下搜索可执行文件。 $PATH 的值像这样 /home/linux-20/bin:/usr/local/bin:/usr/bin:/bin，多个路径用 : 隔开。执行命令时从左到右搜索，左边的优先级高。将用户的目录放前面，使得用户目录的程序比系统目录的程序优先执行。 我们使用的 ls env 等命令，它们完整的路径是 /bin/ls /usr/bin/env，错误配置 $PATH 将带来严重的后果，请看下面的例子： $ # 启动一个 bash 子进程 $ bash $ echo $PATH /home/linux-20/bin:/usr/local/bin:/usr/bin:/bin $ $ # which 可以查看命令匹配到的可执行文件 $ which ls /bin/ls $ which env /usr/bin/env $ which which /usr/bin/which $ $ # 重新配置 PATH $ export PATH=\"/usr/bin\" $ which ls $ which env /usr/bin/env $ ls bash: ls: command not found $ $ # PATH 添加目录 $ export PATH=$PATH:/bin $ echo $PATH /usr/bin:/bin $ which ls /bin/ls $ $ # 删除 PATH $ unset PATH $ which env bash: which: No such file or directory $ $ # 退出 bash 子进程 $ exit exit $ # 父进程不受影响 $ echo $PATH /home/linux-20/bin:/usr/local/bin:/usr/bin:/bin 有些 Linux 程序提供二进制程序包，安装时只需下载并解压，然后配置 $PATH 即可。 比如安装 nodejs，通常的做法是将其二进制程序包解压到 /usr/local/nodejs 目录，然后在系统 profile 中加入一行 export PATH=/usr/local/nodejs/bin:$PATH。要在 $PATH 中增加目录，推荐这样操作：export PATH=/newpath:$PATH export PATH=$PATH:/newpath。 ","date":"2020-10-01","objectID":"/shell-env/:3:0","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"何时加 $ 符号 调用环境变量时需要加 $ 符号，配置环境变量时则不需要。export PATH=/newpath:$PATH 中，前面的 PATH 表示定义一个环境变量，后面的 $PATH 表示调用已有的环境变量。 ","date":"2020-10-01","objectID":"/shell-env/:4:0","tags":["linux基础"],"title":"环境变量","uri":"/shell-env/"},{"categories":["爱技术爱折腾"],"content":"基于 systemd 部署服务","date":"2020-10-01","objectID":"/deploying-service/","tags":["linux基础"],"title":"基于 systemd 部署服务","uri":"/deploying-service/"},{"categories":["爱技术爱折腾"],"content":"准备工作 常用的域名查询命令 dig 和 nslookup 包含在 dnsutils 中，需要安装这个包： sudo apt install dnsutils ","date":"2020-10-01","objectID":"/deploying-service/:1:0","tags":["linux基础"],"title":"基于 systemd 部署服务","uri":"/deploying-service/"},{"categories":["爱技术爱折腾"],"content":"试用 coredns # 切换到临时创建的工作目录 mkdir -p /tmp/coredns \u0026\u0026 cd /tmp/coredns # 下载和解压 curl -L -o coredns.tgz https://github.com/coredns/coredns/releases/download/v1.6.7/coredns_1.6.7_linux_amd64.tgz tar -xf coredns.tgz chmod a+rx coredns # 创建配置文件 # 绑定 5300 端口，避免与其他服务冲突 cat \u003e Corefile \u003c\u003cEOF .:5300 { forward . 119.29.29.29:53 223.5.5.5:53 cache 120 errors log } EOF # 运行 coredns ./coredns 然后新开一个终端窗口进行域名查询： dig www.qq.com @127.0.0.1 -p 5300 此时 coredns 会输出日志： $ ./coredns .:5300 CoreDNS-1.6.7 linux/amd64, go1.13.6, da7f65b [INFO] 127.0.0.1:50303 - 39010 \"A IN www.qq.com. udp 51 false 4096\" NOERROR qr,rd,ra 198 2.007213203s ^C[INFO] SIGINT: Shutting down $ 最后可按 CTRL + C 中断进程。 使用 coredns 很简单，下载后创建一个简单的配置文件就可以运行。以这样的方式运行程序达到快速试用的目的，想要规范地部署还需要多做一些工作。 ","date":"2020-10-01","objectID":"/deploying-service/:2:0","tags":["linux基础"],"title":"基于 systemd 部署服务","uri":"/deploying-service/"},{"categories":["爱技术爱折腾"],"content":"部署 coredns # 需要以 root 执行 # 添加运行 coredns 的用户 useradd coredns -b /var/lib -m -s /usr/sbin/nologin # 下载和解压 curl -L -o /tmp/coredns.tgz https://github.com/coredns/coredns/releases/download/v1.6.7/coredns_1.6.7_linux_amd64.tgz tar -xf /tmp/coredns.tgz -C /usr/local/bin/ chmod a+rx /usr/local/bin/coredns mkdir -p /etc/coredns # 写入 coredns 配置文件 # 这里绑定到 127.0.5.3，避免与其他服务冲突 tee /etc/coredns/Corefile \u003c\u003cEOF \u003e /dev/null . { bind 127.0.5.3 forward . 119.29.29.29:53 223.5.5.5:53 cache 120 errors log } EOF # 写入 systemd unit 文件 tee /etc/systemd/system/coredns.service \u003c\u003cEOF \u003e /dev/null [Unit] Description=CoreDNS DNS server Documentation=https://coredns.io After=network.target [Service] PermissionsStartOnly=true LimitNOFILE=1048576 LimitNPROC=512 CapabilityBoundingSet=CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_BIND_SERVICE NoNewPrivileges=true User=coredns WorkingDirectory=~ ExecStart=/usr/local/bin/coredns -conf=/etc/coredns/Corefile ExecReload=/bin/kill -SIGUSR1 $MAINPID Restart=on-failure [Install] WantedBy=multi-user.target EOF systemctl daemon-reload systemctl start coredns systemctl status coredns 域名查询测试: dig www.qq.com @127.0.5.3 !!! note 以 systemd 部署的服务有 2 个配置文件，一个是 systemd unit 文件，另一个是程序的配置文件。修改前者需要执行 systemctl daemon-reload 使配置生效，修改后者需要执行 systemctl reload UNIT 或者 systemctl restart UNIT 使配置生效。 ","date":"2020-10-01","objectID":"/deploying-service/:3:0","tags":["linux基础"],"title":"基于 systemd 部署服务","uri":"/deploying-service/"},{"categories":["爱技术爱折腾"],"content":"配置网络","date":"2020-10-01","objectID":"/configuration/","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"选择网络配置工具 配置「Linux 操作系统」的网络有以下几款主流的配置工具可供选择： 配置工具 简介 systemd-networkd systemd 是许多发行版默认的 init 程序，其中 systemd-networkd 组件可用于网络配置管理，配置文件在 /etc/systemd/network/。 ifupdown Debian 标准的网络配置工具，配置文件在 /etc/network/interfaces。 NetworkManager 一款容易上手的网络配置工具，使用 nmcli 和 nmtui 进行配置，并支持图形界面，很多桌面版 Linux 使用此工具。 netplan 通过 YAML 文件管理网络配置，支持 systemd-networkd 和 NetworkManager 作为后端程序，配置文件在 /etc/netplan/*.yaml。(Ubuntu Server 18.04 默认使用此工具) 桌面环境建议使用 NetworkManager；在服务器上建议使用默认的配置工具，或者切换到 systemd-networkd。 ","date":"2020-10-01","objectID":"/configuration/:1:0","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"iproute2 iproute2 是「Linux 操作系统」上强大的网络工具，例如 ip address、ip route 命令可用于查看主机网络信息。但是这种底层网络工具配置起来有些麻烦，我们会在下一节介绍它。 ","date":"2020-10-01","objectID":"/configuration/:1:1","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"准备工作 首先敲 ip address 查看一下网卡信息。 进行网络配置之前先看看操作系统有哪些程序已经在工作了，避免造成冲突。比如查看一下相关的配置文件： wc -l /etc/systemd/network/*.network /etc/network/interfaces /etc/netplan/*.yaml grep -v '^#' /etc/systemd/network/*.network /etc/network/interfaces /etc/netplan/*.yaml 选用一款配置工具即可，将不需要的配置文件处理掉。 !!! warning 通过网络连接到计算机时，进行网络配置要非常小心，操作不当将会很尴尬。 ","date":"2020-10-01","objectID":"/configuration/:2:0","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"配置网络 ","date":"2020-10-01","objectID":"/configuration/:3:0","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"systemd-networkd 在 /etc/systemd/network 目录下创建 .network 文件，例如 /etc/systemd/network/50-eth0.network。下面是 eth0 网卡使用 DHCP 的配置： [Match] Name=eth0 [Network] DHCP=ipv4 使用「静态 IP 地址」的配置： [Match] Name=eth0 [Network] Address=192.168.0.15/24 Gateway=192.168.0.1 DNS=119.29.29.29 DNS=223.5.5.5 然后启动 systemd-networkd 服务使配置生效，并设置为开机启动： sudo systemctl restart systemd-networkd sudo systemctl enable systemd-networkd ","date":"2020-10-01","objectID":"/configuration/:3:1","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"ifupdown 编辑 /etc/network/interfaces，下面是 eth0 网卡使用 DHCP 的配置： auto eth0 allow-hotplug eth0 iface eth0 inet dhcp 使用「静态 IP 地址」的配置： auto eth0 iface eth0 inet static address 192.168.0.15/24 gateway 192.168.0.1 dns-nameservers 119.29.29.29 223.5.5.5 配置文件变更以后，输入下面的命令使配置生效： sudo ifdown eth0; sudo ifup eth0 ","date":"2020-10-01","objectID":"/configuration/:3:2","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"netplan 编辑 /etc/netplan/config.yaml，下面是 eth0 网卡使用 DHCP 的配置： network: version: 2 renderer: networkd ethernets: eth0: dhcp4: true 使用「静态 IP 地址」的配置： network: version: 2 renderer: networkd ethernets: eth0: addresses: - 192.168.0.15/24 gateway4: 192.168.0.1 nameservers: addresses: [119.29.29.29, 223.5.5.5] 配置文件变更以后，输入下面的命令使配置生效： sudo netplan apply ","date":"2020-10-01","objectID":"/configuration/:3:3","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"配置 DNS 按照上面的网络配置，通过 DHCP 获取或者静态配置的方式设定了 DNS，相应的后端程序读取配置后，将「DNS服务器」写入 /etc/resolv.conf，此时操作系统可进行域名解析了。 DHCP 是动态的，或者用户需要在不同的网络之间切换，这些因素导致 /etc/resolv.conf 需要动态调整。如果看到该文件像下面这样，以软链接的形式存在，则说明 DNS 可能由某款程序管理，用户不应该直接修改该文件。 $ ls -l /etc/resolv.conf lrwxrwxrwx 1 root root 37 Feb 29 12:20 /etc/resolv.conf -\u003e /run/systemd/resolve/stub-resolv.conf 上面 /run/systemd/resolve/ 这个目录由 systemd-resolved 管理。 ","date":"2020-10-01","objectID":"/configuration/:4:0","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"systemd-resolved systemd-resolved 是 systemd 的一个组件，不需要单独安装，直接将服务启用即可，然后将 /etc/resolv.conf 作为软链接指向 /run/systemd/resolve/stub-resolv.conf，操作如下： sudo systemctl enable systemd-resolved sudo systemctl restart systemd-resolved sudo ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf /run/systemd/resolve/stub-resolv.conf 内容如下： # This file is managed by man:systemd-resolved(8). Do not edit. # … nameserver 127.0.0.53 options edns0 上面可以看到 nameserver 是 127.0.0.53，因为 systemd-resolved 包含一个「DNS服务」，它监听 127.0.0.53。此时操作系统的域名解析请求全部发到这个服务，再由它进行后续的解析。resolvctl status (老版本使用 systemd-resolve --status) 可以查看服务状态，输出信息如下： $ resolvectl status || systemd-resolve --status Global LLMNR setting: yes MulticastDNS setting: yes DNSOverTLS setting: no DNSSEC setting: allow-downgrade DNSSEC supported: yes Current DNS Server: 119.29.29.29 DNS Servers: 119.29.29.29 223.5.5.5 … 上面可以看到，systemd-resolved 后端使用 119.29.29.29 作为「DNS服务器」，通过 /etc/systemd/resolved.conf 这个文件进行管理，配置如下： [Resolve] DNS=119.29.29.29 223.5.5.5 DNSSEC=false 默认情况下 DNS= 为空，这时会使用网卡的 DNS，即动态管理，也可以像上面那样配置为静态的。修改了配置后需要重启服务才能生效 sudo systemctl restart systemd-resolved。 ","date":"2020-10-01","objectID":"/configuration/:4:1","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"锁定 /etc/resolv.conf 如果长期使用固定的 DNS，也可以直接配置 /etc/resolv.conf，然后将其锁定，以确保它不被其他程序修改掉。像下面这样操作: sudo rm -f /etc/resolv.conf echo \"nameserver 119.29.29.29\" | sudo tee /etc/resolv.conf echo \"nameserver 223.5.5.5\" | sudo tee -a /etc/resolv.conf sudo chattr +i /etc/resolv.conf chattr +i 可锁定文件，此时文件不可修改，lsattr /etc/resolv.conf 可以看到文件有个 i 属性，chattr -i /etc/resolv.conf 可解除锁定。 ","date":"2020-10-01","objectID":"/configuration/:4:2","tags":["linux基础"],"title":"配置网络","uri":"/configuration/"},{"categories":["爱技术爱折腾"],"content":"使用 apt 安装软件","date":"2020-10-01","objectID":"/apt/","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"apt 和 dpkg Debian 软件包管理由多个层级组成。底层由 dpkg 和相关程序组成。处在上层的是「apt 系列工具」，例如 apt、apt-get、apt-cache。用户使用最频繁的命令当属 apt 和 dpkg。 apt 旨在为最终用户提供一种简单有效的处理软件包的方法。它将软件包集中存储在软件仓库，用户可以集中获取软件而无需到分散的站点逐个下载，可以用一条简单的命令批量完成软件的安装、升级和移除。 dpkg 也可用于安装和移除软件包，但是没有 apt 方便。面对 apt 无法胜任的工作，我们才会选择它。 ","date":"2020-10-01","objectID":"/apt/:1:0","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"常用示例 ","date":"2020-10-01","objectID":"/apt/:2:0","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"安装 busybox 然后卸载 sudo apt update sudo apt install busybox sudo apt remove busybox ","date":"2020-10-01","objectID":"/apt/:2:1","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"升级所有已安装的软件包 sudo apt update sudo apt upgrade ","date":"2020-10-01","objectID":"/apt/:2:2","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"查看软件包细节 apt show nginx ","date":"2020-10-01","objectID":"/apt/:2:3","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"apt 常用命令介绍 update 更新可用软件包列表。 upgrade 升级已安装的软件包，现有软件包不会被删除。 full-upgrade 执行 upgrade 进行升级。此命令进行完整的升级，必要情况下会删除已安装的软件包。 list 根据名称列出软件包。 search 搜索软件包描述。 show 显示软件包细节。 install 安装软件包。 remove 移除软件包。 purge 移除软件包并删除配置文件。 autoremove 卸载所有自动安装且不再使用的软件包。 !!! note upgrade 可升级所有已安装的软件包，即更新操作系统。升级操作系统大版本通常需要删除一些遗弃的软件包，因此需要使用 full-upgrade，例如从 Debian 9 升级到 Debian 10。 ","date":"2020-10-01","objectID":"/apt/:3:0","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"配置 apt 源 apt 从一个或多个「软件仓库」(源) 下载软件包并将其安装到你的计算机上。源通常是网络服务器，例如官方的 DebianStable 仓库。因为网速问题，我们通常会选择国内的镜像服务器（腾讯软件源、阿里云开源镜像站、清华大学开源软件镜像站），或者使用私有的服务器。 ","date":"2020-10-01","objectID":"/apt/:4:0","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"配置国内镜像源 这里以 Debian 10 和 Ubuntu 18.04 为例，其他版本请参考相应的文档：https://developer.aliyun.com/mirror/ Debian 10 sudo tee /etc/apt/sources.list \u003c\u003cEOF deb https://mirrors.aliyun.com/debian buster main deb-src https://mirrors.aliyun.com/debian buster main deb https://mirrors.aliyun.com/debian-security/ buster/updates main deb-src https://mirrors.aliyun.com/debian-security/ buster/updates main deb https://mirrors.aliyun.com/debian buster-updates main deb-src https://mirrors.aliyun.com/debian buster-updates main EOF sudo apt update 上面的操作可以稍微改进一下，将主机地址和系统版本替换为变量，如下： sHost=\"mirrors.aliyun.com\" release=\"buster\" sudo tee /etc/apt/sources.list \u003c\u003cEOF deb http://${sHost}/debian ${release} main deb-src http://${sHost}/debian ${release} main deb http://${sHost}/debian-security ${release}/updates main deb-src http://${sHost}/debian-security ${release}/updates main deb http://${sHost}/debian ${release}-updates main deb-src http://${sHost}/debian ${release}-updates main EOF sudo apt update Ubuntu 18.04 sudo tee /etc/apt/sources.list \u003c\u003cEOF deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted EOF sudo apt update !!! note apt update 根据 sources.list 更新可用软件包列表，修改配置文件后执行 update 才能正式生效。用户可以每次安装或升级软件时都执行一次 update，也可以仅在重要的操作前执行。本书其他地方可能会忽略这一步。 ","date":"2020-10-01","objectID":"/apt/:4:1","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"添加第三方源 下面是安装 vscode 的步骤： # 安装 GPG curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u003e packages.microsoft.gpg sudo install -o root -g root -m 644 packages.microsoft.gpg /usr/share/keyrings/ # 添加源 sudo sh -c 'echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main\" \u003e /etc/apt/sources.list.d/vscode.list' # 更新可用软件包列表 sudo apt update # 安装 vscode sudo apt install code 第三方软件源可以写入 /etc/apt/sources.list，但更好的安排是在 /etc/apt/sources.list.d 目录下创建一个 list 文件，当不需要时可以删除相应的文件而避免频繁修改一个主配置文件。当 /etc/apt/sources.list.d/vscode.list 被删除后，vscode 仍然可以正常使用，但无法被 apt upgrade 升级。 ","date":"2020-10-01","objectID":"/apt/:4:2","tags":["linux基础"],"title":"使用 apt 安装软件","uri":"/apt/"},{"categories":["爱技术爱折腾"],"content":"网络工具 iproute2","date":"2020-10-01","objectID":"/iproute2/","tags":["linux基础"],"title":"网络工具 iproute2","uri":"/iproute2/"},{"categories":["爱技术爱折腾"],"content":"net-tools 是一款知名的老牌网络工具。Linux kernel 2.2 开始对网络子系统进行了重新设计，老牌的网络工具难以继续与之适配。iproute2 是基于新的网络子系统开发出来的工具，可以管理路由、网络接口、隧道、流量控制以及与网络相关的设备驱动程序。 下面是 iproute2 和 net-tools 相关命令的对照： iproute2 命令 net-tools 命令 用途 ip address, ip link ifconfig 管理网络接口和地址 ip route route 管理路由表 arp ip neigh 管理 arp 表 ss netstat 查看网络连接信息 ","date":"2020-10-01","objectID":"/iproute2/:0:0","tags":["linux基础"],"title":"网络工具 iproute2","uri":"/iproute2/"},{"categories":["爱技术爱折腾"],"content":"语法介绍 ip 命令的语法如下： ip [ OPTIONS ] OBJECT { COMMAND | help } OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics | token | macsec } ip 命令可以管理很多对象，上面已经列出来了。众多对象及其子命令要全部记住可不容易，所以 help 命令很有用，所有对象均支持 help 命令，例如 ip help、ip link help。 命令中的字段可以不敲完整，例如 ip address 可以敲成 ip addr、ip a；而 ip addrlabel 至少要敲出 ip addrl，因为命令识别有优先级顺序。直接敲 ip address 后面什么都没有，会被程序识别为 ip address show。 ","date":"2020-10-01","objectID":"/iproute2/:1:0","tags":["linux基础"],"title":"网络工具 iproute2","uri":"/iproute2/"},{"categories":["爱技术爱折腾"],"content":"查看系统网络信息 查看「IP地址」、路由表和「ARP表」是最常规的需求，命令如下： # 查看「IP地址」 ip address # 查看路由表 ip route # 查看「ARP表」 ip neigh 执行后输出信息如下： $ ip address 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 52:54:00:b6:13:16 brd ff:ff:ff:ff:ff:ff inet 192.168.121.142/24 brd 192.168.121.255 scope global dynamic eth0 valid_lft 2285sec preferred_lft 2285sec $ $ ip route default via 192.168.121.1 dev eth0 192.168.121.0/24 dev eth0 proto kernel scope link src 192.168.121.142 $ $ ip neigh 192.168.121.1 dev eth0 lladdr 52:54:00💿70:3a REACHABLE ","date":"2020-10-01","objectID":"/iproute2/:2:0","tags":["linux基础"],"title":"网络工具 iproute2","uri":"/iproute2/"},{"categories":["爱技术爱折腾"],"content":"配置网络 这里我们通过一个小实验简单了解一下 iproute2 如何配置网络： $ sudo ip link add test-br type bridge $ sudo ip address change 10.9.2.1/24 dev test-br $ sudo ip link set test-br up $ ip address show test-br 96: test-br: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000 link/ether 8a:8f:ab:0b:12:23 brd ff:ff:ff:ff:ff:ff inet 10.9.2.1/24 scope global test-br valid_lft forever preferred_lft forever $ ping -c 1 10.9.2.1 PING 10.9.2.1 (10.9.2.1) 56(84) bytes of data. 64 bytes from 10.9.2.1: icmp_seq=1 ttl=64 time=0.066 ms --- 10.9.2.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.066/0.066/0.066/0.000 ms $ $ sudo ip link del test-br 我们把相关的命令单独列出来： # 创建网卡 sudo ip link add test-br type bridge # 配置「IP地址」 sudo ip address change 10.9.2.1/24 dev test-br # 启动网卡并查看网卡信息 sudo ip link set test-br up ip address show test-br # 删除网卡 sudo ip link del test-br 上面对网卡进行增删改的操作都需要 root 权限，并且这些配置在重启后会失效。 ","date":"2020-10-01","objectID":"/iproute2/:3:0","tags":["linux基础"],"title":"网络工具 iproute2","uri":"/iproute2/"},{"categories":["爱技术爱折腾"],"content":"文件权限基础","date":"2020-10-01","objectID":"/basic/","tags":["linux基础"],"title":"文件权限基础","uri":"/basic/"},{"categories":["爱技术爱折腾"],"content":"查看文件权限 ls -l 可查看文件权限，例如： $ ls -l /home drwxr-xr-x 2 root root 4096 12月 12 18:16 docker-bound -rw-r--r-- 1 guest root 0 1月 16 14:31 foo.txt drwxr-xr-x 20 guest guest 4096 5月 4 2019 guest 文件类型和权限 硬链接数量 owner group drwxr-xr-x 2 root root -rw-r–r– 1 guest root drwxr-xr-x 8 guest guest 第一段信息 drwxr-xr-x，其中第一位表示文件类型，后面 9 位表示文件权限。这 9 位每 3 位一组，共 3 组，分别表示 “owner/group/其他用户\"权限。 文件类型字符含义： - 普通文件 d 目录 (目录也是文件，它的类型是目录) l 符号链接 文件权限字符含义： r 读权限 w 写权限 x 执行权限 (如果是目录则表示搜寻权限) - 占位符，表示没有该位权限 案例解析： drwxr-xr-x 表示一个目录，owner 具有全部读写执行权限，group 和其他用户只有读和执行权限。 -rw-r--r-- 表示一个普通文件，owner 具有读写权限，group 和其他用户只有读权限。 -rwxrwxrwx 表示一个普通文件，所有用户具有全部读写执行权限。 ","date":"2020-10-01","objectID":"/basic/:1:0","tags":["linux基础"],"title":"文件权限基础","uri":"/basic/"},{"categories":["爱技术爱折腾"],"content":"目录的权限 文件权限中的 x 我们通常说执行权限，但目录文件的 “执行权限” 有些复杂。 可以这样来理解，目录是一个包含若干文件名的列表。x 表示搜寻列表的权限，而仅有这个权限是没有用的，x 应该与 r/w 结合起来控制目录的权限。正常的目录权限应该是 rwx、r-x、---。 r-x 表示可以读取和搜寻文件列表，但不能在目录下增加、删除以及重命名文件。 rwx 表示具有完整的权限。 如果目录的权限是 r-- 或者 --x，则是异常的。 ","date":"2020-10-01","objectID":"/basic/:1:1","tags":["linux基础"],"title":"文件权限基础","uri":"/basic/"},{"categories":["爱技术爱折腾"],"content":"特殊权限 set-user-ID，文件被执行时以文件 owner 运行。 set-group-ID，文件被执行时以文件 group 运行。对于目录，在目录下创建的文件将与目录的 group 一致，这个特性便于目录共享。 防删标记，限制只有文件的 owner 可以删除文件。 $ mkdir foo bar $ chmod +t,ug+s foo bar $ ls -l drwsr-sr-t 2 linux-20 linux-20 4096 1月 18 12:22 bar drwsr-sr-t 2 linux-20 linux-20 4096 1月 18 12:22 foo $ chmod a-x foo $ ls -l drwsr-sr-t 2 linux-20 linux-20 4096 1月 18 12:22 bar drwSr-Sr-T 2 linux-20 linux-20 4096 1月 18 12:22 foo 上面的例子，-rwsr-sr-t 中 s、t 表示特殊权限。因为这个符号占用了 x 的位置，为了区分，小写字母 s、t 表示包含 x 权限，大小字母 S、T 表示不含 x 权限。 ","date":"2020-10-01","objectID":"/basic/:2:0","tags":["linux基础"],"title":"文件权限基础","uri":"/basic/"},{"categories":["爱技术爱折腾"],"content":"选择 shell","date":"2020-10-01","objectID":"/choose-shell/","tags":["linux基础"],"title":"选择 shell","uri":"/choose-shell/"},{"categories":["爱技术爱折腾"],"content":"目前最流行的 shell 程序是 bash，全称 “Bourne-Again shell”，它是很多「Linux 发行版」默认的「登录 shell」，此外还有其他几款知名的 shell： Bourne shell：曾经最流行的 shell，bash 的名字来自于它。 ash (Almquist shell)：一款 BSD 许可的 Bourne shell 替代产品，体积小巧，通常在资源受限的环境中使用。 dash (Debian Almquist shell)：debian 版本的 ash。 zsh (Z shell)：目前很流行的一款 shell，它在 Bourne shell 的基础上做了很多改进，并包含 bash 和其他一些 shell 的功能。2019年10月发布的 macOS Catalina 使用 zsh 作为默认 shell。 Busybox: 它将大量的 Unix 工具集成在一起，其中包括 shell 程序，用的是 ash (Almquist shell)。 以上这些 shell 均符合 POSIX 规范，在不同 shell 之间切换是受支持的。但使用某款 shell 增强的功能，可能在其他 shell 上不受支持。 !!! note 本书使用 bash 作为「默认 shell」。 ","date":"2020-10-01","objectID":"/choose-shell/:0:0","tags":["linux基础"],"title":"选择 shell","uri":"/choose-shell/"},{"categories":["爱技术爱折腾"],"content":"切换 shell 要切换到其他 shell，直接运行该程序即可，例如： $ # 从 bash 切换到 zsh $ zsh $ $ # 退出 zsh，返回到 bash linux-20@sdeb ~ % exit $ /etc/shells 登记了可用的登录 shell，echo $SHELL 查看「默认 shell」： $ cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash /bin/zsh $ $ echo $SHELL /bin/bash usermod 或者 chsh 可修改「默认 shell」： usermod -s /bin/zsh linux-20 chsh -s /bin/zsh linux-20 ","date":"2020-10-01","objectID":"/choose-shell/:1:0","tags":["linux基础"],"title":"选择 shell","uri":"/choose-shell/"},{"categories":["爱技术爱折腾"],"content":"执行文件","date":"2020-10-01","objectID":"/exec-file/","tags":["linux基础"],"title":"执行文件","uri":"/exec-file/"},{"categories":["爱技术爱折腾"],"content":" #!/bin/bash foo=\"linux-20\" ps 将上面的内容保存为 foo.sh 文件，有以下方式可以执行该文件： ./foo.sh 创建子进程并执行文件，需要文件有可执行权限。 bash ./foo.sh 创建子进程并执行文件。 . ./foo.sh 在当前进程执行。 source ./foo.sh 等同于 . ./foo.sh。 执行文件时如果文件路径不包含斜杠 /，那么会优先到 $PATH 下面去搜寻文件。因为 . 代表当前目录，./foo.sh 这种写法就明确了是当前目录下的文件，避免了不确定性。 第一行 #!/bin/bash 指定 /bin/bash 作为解释器，省略这一行将使用默认解释器。 ","date":"2020-10-01","objectID":"/exec-file/:0:0","tags":["linux基础"],"title":"执行文件","uri":"/exec-file/"},{"categories":["爱技术爱折腾"],"content":"当前进程和子进程的区别 $ chmod a+x foo.sh $ $ unset foo; ./foo.sh; echo $foo PID TTY TIME CMD 11411 pts/2 00:00:00 foo.sh 11412 pts/2 00:00:00 ps 22825 pts/2 00:00:09 bash $ unset foo; . ./foo.sh; echo $foo PID TTY TIME CMD 11414 pts/2 00:00:00 ps 22825 pts/2 00:00:09 bash linux-20 可以看到，在当前进程中执行会把文件中定义的变量保留下来，而在子进程中执行则不会，这是最重要的区别。另外子进程不会继承父进程的局部变量，这也是一个因素。因此，当我们需要加载一个文件中的变量时则需要 source 的方式执行，profile 文件就需要这样执行；否则，优先在子进程中执行文件，这是常用的方式。 ","date":"2020-10-01","objectID":"/exec-file/:1:0","tags":["linux基础"],"title":"执行文件","uri":"/exec-file/"},{"categories":["爱技术爱折腾"],"content":"终端和 shell","date":"2020-10-01","objectID":"/tty-shell/","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"用户界面 对于 Linux 用户来说，最关心的当然是用户界面。用户界面也称为 shell，有「命令行界面」(CLI) 和「图形界面」(GUI)。因为它处在操作系统的最外层，所以称之为 shell (壳)。 中文环境里面独立出现的 shell 通常特指「命令行 shell」，而不将图形界面称为 shell。Unix-like 操作系统上的「命令行 shell」 又称 “Unix shell”。为了表达简练，后文中单独出现的 shell 特指 “Unix shell”。 ","date":"2020-10-01","objectID":"/tty-shell/:1:0","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"shell shell 既是用户与操作系统交互的界面，也是一门脚本语言，支持交互模式和非交互模式。交互模式下，接收键盘输入的命令。非交互模式下，从文件读取一连串的命令并执行，此文件称为 shell 脚本。 shell 为 Linux 上面丰富多样的程序提供了用户界面，并且支持组合使用这些程序。使用 shell 脚本，用户可以灵活和高效地完成工作任务。 此外 shell 还提供了专门为交互使用而设计的功能，包括作业控制、命令行编辑、命令历史记录和命令别名。 ","date":"2020-10-01","objectID":"/tty-shell/:1:1","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"图形界面 对于 Linux，图形界面是可选的，但它对于操作系统是举足轻重的。 早期的计算机只有「命令行界面」，那时候计算机是专业人员的工具。图形界面用起来比较舒适，上手容易，它能满足各类人群的需求。可以说图形界面推动了计算机 (包括移动终端) 迅速普及。 对于使用 shell 工作的人群来说，通过图形界面可以舒适地使用 shell。 *♥.•´¸.•*´✶´♡ ¸.•*´´♡🌼🍃🌼🍃* *_🌈○💙_Good morning❤🌹* *💚.•´¸.•*´✶´♡ ¸.•*´´♡⛅* *° ☆ ° ˛*˛☆_Π____*。*˚☆* *˚ ˛★˛•˚ */______/~＼。˚ ˚ ˛* *˚ ˛•˛• ˚ ｜ 田田 ｜門｜ ˚* *🌴╬═🌴╬╬🌴╬╬🌴═╬╬═🌴* ","date":"2020-10-01","objectID":"/tty-shell/:1:2","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"终端 终端 (terminal) 是用户与操作系统用户界面 (shell) 进行交互的设备。早期的计算机终端是一类硬件设备，一台计算机可以连接多个终端机供多个用户使用。 随着技术的发展，计算机逐渐淘汰了笨重的硬件终端机，取而代之的是软件终端，即虚拟终端。Linux 上与终端相关的术语如下： tty - 泛指终端，可以是硬件终端也可以是软件终端。tty 代表 TeleTYpewriter，它曾是早期计算机的硬件终端，Linux 一直沿用这个名字作为终端的代名词。 pty - 仿真 tty，即仿真终端，也称伪终端。 ptmx, pts - pty 主端和从端。 ","date":"2020-10-01","objectID":"/tty-shell/:2:0","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"tty tty 命令可以查看当前 shell 所属的 tty 信息： $ tty /dev/pts/2 上面的是在图形界面使用 pty 得到的信息，接下来按 Ctrl + Alt + F5 切换 tty (此 tty 是字符终端)，然后查看 tty： $ tty /dev/tty5 以上 /dev/pts/2、/dev/tty5 分别对应不同的 tty： /dev/ttyN 由操作系统核心组件管理，需要物理线缆连接才可使用，这样的 tty 也称为控制台终端。 /dev/pts/N 由「pty 程序」(比如 GNOME Terminal、SSH) 管理，每建立一个 pty 会话都会创建对应的 pts 文件。 who 可以查看所有登录的用户和对应的 tty： $ who linux-20 tty2 Feb 15 11:14 (tty2) user01 tty5 Feb 16 15:07 上面显示 tty2 和 tty5，新打开的控制台终端对应 tty5 (因为前面使用 Ctrl + Alt + F5 切换，另外用户名和登录时间也可以作为判断依据)，说明原先使用的图形界面对应 tty2，按 Ctrl + Alt + F2 可返回。当图形界面崩溃了可切换到非图形的控制台终端进行诊断。 ","date":"2020-10-01","objectID":"/tty-shell/:2:1","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"终端和 shell 终端和 shell 需要配套使用，打开终端即运行 shell，每个终端都有与之对应的 shell 进程。 终端负责将输入信息转化为控制序列，shell 负责将控制序列转化为命令。比如我们分别输入 cd /tmp 和 # cd /tmp，对终端来说只是输入字符多少的问题，而对 shell 来说则代表完全不同的信息。 ","date":"2020-10-01","objectID":"/tty-shell/:3:0","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":["爱技术爱折腾"],"content":"图形界面使用 shell 上面已经说过了，在图形界面中可以通过「pty 程序」(比如 GNOME Terminal) 使用 shell，但是在陌生的图形界面上有时并不容易找到它。「pty 程序」一般包含关键字 “terminal” (终端)，可以通过搜索关键字得到。 ","date":"2020-10-01","objectID":"/tty-shell/:4:0","tags":["linux基础"],"title":"终端和 shell","uri":"/tty-shell/"},{"categories":null,"content":"检查网络端口被哪个程序占用 ","date":"0001-01-01","objectID":"/port-in-use/:0:0","tags":null,"title":"","uri":"/port-in-use/"},{"categories":null,"content":"操作简介 # 查看进程占用的 80 端口 sudo ss -tlnp | grep \":80\\b\" # 查看 Docker 占用的 80 端口 sudo docker ps | grep \":80-\u003e\" ","date":"0001-01-01","objectID":"/port-in-use/:1:0","tags":null,"title":"","uri":"/port-in-use/"},{"categories":null,"content":"问题详解 一台主机上，如果 2 个程序绑定相同 ip_address:port，是无法同时运行的，我们经常需要在安装程序之前检查端口是否空闲。运行 Docker 容器映射端口时，也会存在同样的问题。下面是运行 Docker 容器重复映射 80 端口的报错： $ docker run -p 80:80 -d nginx ... Error starting userland proxy: listen tcp 0.0.0.0:80: bind: address already in use. 这里我们用网络工具 ss 来进行排查，它是 netstat 的替代者。ss -tln 可以查看主机正在监听的 TCP 端口，通过过滤器可以筛选出 80 端口： sudo ss -tlnp sport = :80 # 或者使用 grep 进行过滤 sudo ss -tlnp | grep \":80\\b\" $ sudo ss -tlnp | grep \":80\\b\" LISTEN 0 128 *:80 *:* users:((\"docker-proxy\",pid=13256,fd=4)) 没有输出表示端口空闲。如果输出包括 apache 或者 nginx，则需要停掉相关的服务。上面的输出包含 docker 相关进程，还需要找到对应的容器： sudo docker ps | grep \":80-\u003e\" $ sudo docker ps | grep \":80-\u003e\" d25cdf73b351 nginx \"nginx -g 'daemon of…\" 0.0.0.0:80-\u003e80/tcp nginx-test 发现容器 d25cdf73b351 映射了 80 端口，然后停止或删除容器：sudo docker stop d25cdf73b351 ","date":"0001-01-01","objectID":"/port-in-use/:2:0","tags":null,"title":"","uri":"/port-in-use/"},{"categories":null,"content":"ss 常用选项介绍 -n, --numeric 不解析服务名，始终显示端口数字 -a, --all 显示所有 sockets -l, --listening 显示监听的 sockets -p, --processes 显示所属进程，需要 root 权限 -t, --tcp 仅显示 tcp sockets -u, --udp 仅显示 udp sockets ","date":"0001-01-01","objectID":"/port-in-use/:3:0","tags":null,"title":"","uri":"/port-in-use/"}]